[[active-record-migrations]]
== Active Record 迁移
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
迁移是 Active Record 的一个特性，允许我们按时间顺序管理数据库模式。有了迁移，就不必再用纯 SQL 来修改数据库模式，而是可以使用简单的 Ruby DSL 来描述对数据表的修改。

读完本文后，你将学会：

* 用于创建迁移的生成器
* Active Record 提供的用于操作数据库的方法
* 用于操作迁移和数据库模式的 `bin/rails` 任务
* 迁移和 `schema.rb` 文件的关系
--

[[migration-overview]]
=== 迁移概述

迁移是以一致和轻松的方式按时间顺序修改数据库模式的实用方法。它使用 Ruby DSL，因此不必手动编写 SQL，从而实现了数据库无关的数据库模式的创建和修改。

我们可以把迁移看做数据库的新“版本”。数据库模式一开始并不包含任何内容，之后通过一个个迁移来添加删除数据表、字段和记录。
Active Record 知道如何沿着时间线更新数据库模式，使其从任何历史版本更新为最新版本。Active Record 还会更新 `db/schema.rb` 文件，以匹配最新的数据库结构。

下面是一个迁移的示例：

[source,ruby]
----
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
----

这个迁移添加了 `products` 数据表，数据表中包含 `name` 字符串字段和 `description` 文本字段。同时隐式添加了 `id` 主键字段，这是所有 Active Record 模型的默认主键。`timestamps` 宏添加了 `created_at` 和 `updated_at` 两个字段。后面这几个特殊字段只要存在就都由 Active Record 自动管理。

注意这里定义的对数据库的修改是按时间进行的。在这个迁移运行之前，数据表还不存在。在这个迁移运行之后，数据表就被创建了。Active Record 还知道如何撤销这个迁移：如果我们回滚这个迁移，数据表就会被删除。

对于支持事务并提供了用于修改数据库模式的语句的数据库，迁移被包装在事务中。如果数据库不支持事务，那么当迁移失败时，已成功的那部分操作将无法回滚。这种情况下只能手动完成相应的回滚操作。

NOTE: 某些查询不能在事务内部运行。如果数据库适配器支持 DDL 事务，就可以使用 `disable_ddl_transaction!` 方法在某个迁移中临时禁用事务。

如果想在迁移中完成一些 Active Record 不知如何撤销的操作，可以使用 `reversible` 方法：

[source,ruby]
----
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def change
    reversible do |dir|
      change_table :products do |t|
        dir.up   { t.change :price, :string }
        dir.down { t.change :price, :integer }
      end
    end
  end
end
----

或者用 `up` 和 `down` 方法来代替 `change` 方法：

[source,ruby]
----
class ChangeProductsPrice < ActiveRecord::Migration[5.0]
  def up
    change_table :products do |t|
      t.change :price, :string
    end
  end

  def down
    change_table :products do |t|
      t.change :price, :integer
    end
  end
end
----

[[creating-a-migration]]
=== 创建迁移

[[creating-a-standalone-migration]]
==== 创建独立的迁移

迁移文件储存在 `db/migrate` 文件夹中，一个迁移文件包含一个迁移类。文件名采用 `YYYYMMDDHHMMSS_create_products.rb` 形式，即 UTC 时间戳加上下划线再加上迁移的名称。迁移类的名称（驼峰风格）应该匹配文件名中迁移的名称。例如，在 `20080906120000_create_products.rb` 文件中应该定义 `CreateProducts` 类，在 `20080906120001_add_details_to_products.rb` 文件中应该定义 `AddDetailsToProducts` 类。Rails 根据文件名的时间戳部分确定要运行的迁移和迁移运行的顺序，因此当需要把迁移文件复制到其他 Rails 程序，或者自己生成迁移文件时，一定要注意迁移运行的顺序。

当然，计算时间戳不是什么有趣的事，因此 Active Record 提供了生成器：

----
$ bin/rails generate migration AddPartNumberToProducts
----

上面的命令会创建空的迁移，并进行了适当命名：

[source,ruby]
----
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
  end
end
----

如果迁移名称是 `AddXXXToYYY` 或 `RemoveXXXFromYYY` 的形式，并且后面跟着字段名和类型列表，那么会生成包含合适的 `add_column` 或 `remove_column` 语句的迁移。

----
$ bin/rails generate migration AddPartNumberToProducts part_number:string
----

上面的命令会生成：

[source,ruby]
----
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
  end
end
----

还可以像下面这样在新建字段上添加索引：

----
$ bin/rails generate migration AddPartNumberToProducts part_number:string:index
----

上面的命令会生成：

[source,ruby]
----
class AddPartNumberToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_index :products, :part_number
  end
end
----

类似地，还可以生成用于删除字段的迁移：

----
$ bin/rails generate migration RemovePartNumberFromProducts part_number:string
----

上面的命令会生成：

[source,ruby]
----
class RemovePartNumberFromProducts < ActiveRecord::Migration[5.0]
  def change
    remove_column :products, :part_number, :string
  end
end
----

还可以生成用于添加多个字段的迁移，例如：

----
$ bin/rails generate migration AddDetailsToProducts part_number:string price:decimal
----

上面的命令会生成：

[source,ruby]
----
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :part_number, :string
    add_column :products, :price, :decimal
  end
end
----

如果迁移名称是 `CreateXXX` 的形式，并且后面跟着字段名和类型列表，那么会生成用于创建包含指定字段的 `XXX` 数据表的迁移。例如：

----
$ bin/rails generate migration CreateProducts name:string part_number:string
----

上面的命令会生成：

[source,ruby]
----
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.string :part_number
    end
  end
end
----

和往常一样，上面的命令生成的代码只是一个起点，我们可以修改 `db/migrate/YYYYMMDDHHMMSS_add_details_to_products.rb` 文件，根据需要增删代码。

生成器也接受 `references` 字段类型作为参数（还可使用 `belongs_to`），例如：

----
$ bin/rails generate migration AddUserRefToProducts user:references
----

上面的命令会生成：

[source,ruby]
----
class AddUserRefToProducts < ActiveRecord::Migration[5.0]
  def change
    add_reference :products, :user, index: true, foreign_key: true
  end
end
----

这个迁移会创建 `user_id` 字段并添加索引。关于 `add_reference` 选项的更多介绍，请参阅 link:http://api.rubyonrails.org/classes/ActiveRecord/ConnectionAdapters/SchemaStatements.html#method-i-add_reference[API 文档]。

如果迁移名称中包含 `JoinTable`，生成器会创建联合数据表：

----
$ bin/rails g migration CreateJoinTableCustomerProduct customer product
----

上面的命令会生成：

[source,ruby]
----
class CreateJoinTableCustomerProduct < ActiveRecord::Migration[5.0]
  def change
    create_join_table :customers, :products do |t|
      # t.index [:customer_id, :product_id]
      # t.index [:product_id, :customer_id]
    end
  end
end
----

[[model-generators]]
==== 模型生成器

模型和脚手架生成器会生成适用于添加新模型的迁移。这些迁移中已经包含用于创建有关数据表的指令。如果我们告诉 Rails 想要哪些字段，那么添加这些字段所需的语句也会被创建。例如，运行下面的命令：

----
$ bin/rails generate model Product name:string description:text
----

上面的命令会创建下面的迁移：

[source,ruby]
----
class CreateProducts < ActiveRecord::Migration[5.0]
  def change
    create_table :products do |t|
      t.string :name
      t.text :description

      t.timestamps
    end
  end
end
----

我们可以根据需要添加字段名称/类型对，没有数量限制。


[[passing-modifiers]]
==== 传递修饰符

可以直接在命令行中传递常用的 <<active_record_migrations#column-modifiers>>。这些类型修饰符用大括号括起来，放在字段类型之后。例如，运行下面的命令：

----
$ bin/rails generate migration AddDetailsToProducts 'price:decimal{5,2}' supplier:references{polymorphic}
----

上面的命令会创建下面的迁移：

[source,ruby]
----
class AddDetailsToProducts < ActiveRecord::Migration[5.0]
  def change
    add_column :products, :price, :decimal, precision: 5, scale: 2
    add_reference :products, :supplier, polymorphic: true, index: true
  end
end
----

TIP: 关于传递修饰符的更多介绍，请参阅生成器的命令行帮助信息。

[[writing-a-migration]]
=== 编写迁移

使用生成器创建迁移后，就可以开始写代码了。

[[creating-a-table]]
==== 创建数据表

`create_table` 方法是最基础、最常用的方法，其代码通常是由模型或脚手架生成器生成的。典型的用法像下面这样：

[source,ruby]
----
create_table :products do |t|
  t.string :name
end
----

上面的命令会创建包含 `name` 字段的 `products` 数据表（后面会介绍，数据表还包含自动创建的 `id` 字段）。

默认情况下，`create_table` 方法会创建 `id` 主键。可以用 `:primary_key` 选项来修改主键名称，还可以传入 `id: false` 选项以禁用主键。如果需要传递数据库特有的选项，可以在 `:options` 选项中使用 SQL 代码片段。例如：

[source,ruby]
----
create_table :products, options: "ENGINE=BLACKHOLE" do |t|
  t.string :name, null: false
end
----

上面的代码会在用于创建数据表的 SQL 语句末尾加上 `ENGINE=BLACKHOLE`（如果使用 MySQL 或 MarialDB，默认选项是 `ENGINE=InnoDB`）。

还可以传递带有数据表描述信息的 `:comment` 选项，这些注释会被储存在数据库中，可以使用 MySQL Workbench、PgAdmin III 等数据库管理工具查看。对于大型数据库，强列推荐在程序迁移中添加注释。目前只有 MySQL 和 PostgreSQL 适配器支持注释功能。

[[creating-a-join-table]]
==== 创建联合数据表

`create_join_table` 方法用于创建 HABTM（has and belongs to many）联合数据表。典型的用法像下面这样：

[source,ruby]
----
create_join_table :products, :categories
----

上面的代码会创建包含 `category_id` 和 `product_id` 字段的 `categories_products` 数据表。这两个字段的 `:null` 选项默认设置为 `false`，可以通过 `:column_options` 选项重载这一设置：

[source,ruby]
----
create_join_table :products, :categories, column_options: { null: true }
----

联合数据表的名称默认由 `create_join_table` 方法的前两个参数按字母顺序组合而来。可以传入 `:table_name` 选项来自定义联合数据表的名称：

[source,ruby]
----
create_join_table :products, :categories, table_name: :categorization
----

上面的代码会创建 `categorization` 数据表。

`create_join_table` 方法也接受块作为参数，用于添加索引（默认未创建的索引）或附加字段：

[source,ruby]
----
create_join_table :products, :categories do |t|
  t.index :product_id
  t.index :category_id
end
----

[[changing-tables]]
==== 修改数据表

`change_table` 方法和 `create_table` 非常类似，用于修改现有的数据表。它的用法和 `create_table` 方法风格类似，但传入块的对象有更多用法。例如：

[source,ruby]
----
change_table :products do |t|
  t.remove :description, :name
  t.string :part_number
  t.index :part_number
  t.rename :upccode, :upc_code
end
----

上面的代码删除 `description` 和 `name` 字段，创建 `part_number` 字符串字段并添加索引，最后重命名 `upccode` 字段。

[[changing-columns]]
==== 修改字段
