[[active-record-callbacks]]
== Active Record 回调
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
本文介绍如何介入 Active Record 对象的生命周期。

读完后，你将学会：

* Active Record 对象的生命周期。
* 如何创建用于响应对象生命周期内事件的回调方法。
* 如何把常用的回调封装到特殊类中。
--

[[the-object-life-cycle]]
=== 对象的生命周期

在 Rails 程序正常操作期间，对象可以被创建、更新或删除。 Active Record 为对象的生命周期提供了钩子，使我们可以控制程序及其数据。

回调使我们可以在对象状态更改之前或之后触发逻辑。

[[callbacks-overview]]
=== 回调概述

回调是在对象生命周期的某些时刻被调用的方法。通过回调，我们可以编写在创建、保存、更新、删除、验证或从数据库加载 Active Record 对象时执行的代码。

[[callback-registration]]
==== 注册回调

回调在使用之前需要注册。我们可以先把回调定义为普通方法，然后使用宏样式类方法把这些普通方法注册为回调：

[[source,ruby]]
----
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_validation :ensure_login_has_a_value

  protected
    def ensure_login_has_a_value
      if login.nil?
        self.login = email unless email.blank?
      end
    end
end
----

宏样式类方法也接受块参数。如果块中的代码短到可以放在一行里，就可以考虑使用块参数这种编程风格：

[source,ruby]
----
class User < ApplicationRecord
  validates :login, :email, presence: true

  before_create do
    self.name = login.capitalize if name.blank?
  end
end
----

回调也可以注册为仅被某些生命周期事件触发：

[source,ruby]
----
class User < ApplicationRecord
  before_validation :normalize_name, on: :create

  # :on takes an array as well
  after_validation :set_location, on: [ :create, :update ]

  protected
    def normalize_name
      self.name = name.downcase.titleize
    end

    def set_location
      self.location = LocationService.query(self)
    end
end
----

通常应该把回调定义为受保护的方法或私有方法。如果把回调定义为公共方法，就可以从模型外部调用回调，这样做违反了对象封装原则。

[[available-callbacks]]
=== 可用的回调

下面按照回调在 Rails 程序正常操作期间被调用的顺序，列出了所有可用的 Active Record 回调：

[[creating-an-object]]
==== 创建对象

* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_create`
* `around_create`
* `after_create`
* `after_save`
* `after_commit/after_rollback`

[[updating-an-object]]
==== 更新对象

* `before_validation`
* `after_validation`
* `before_save`
* `around_save`
* `before_update`
* `around_update`
* `after_update`
* `after_save`
* `after_commit/after_rollback`

[[destroying-an-object]]
==== 删除对象

* `before_destroy`
* `around_destroy`
* `after_destroy`
* `after_commit/after_rollback`

WARNING: 无论按什么顺序注册回调，在创建和更新对象时，`after_save` 回调总是在更明确的 `after_create` 和 `after_update` 回调之后被调用。

[[after-initialize-and-after-find]]
==== `after_initialize` 和 `after_find` 回调

当 Active Record 对象被实例化时，不管是通过直接使用 `new` 方法还是从数据库加载记录，都会调用 `after_initialize` 回调。使用这个回调可以避免直接重载 Active Record 的 `initialize` 方法。

当 Active Record 从数据库加载记录时，会调用 `after_find` 回调。 如果同时定义了 `after_initialize` 和 `after_find` 回调，会先调用 `after_find` 回调。

`after_initialize` 和 `after_find` 回调没有对应的 `before_*` 回调，这两个回调的注册方法和其他 Active Record 回调一样。

[source,ruby]
----
class User < ApplicationRecord
  after_initialize do |user|
    puts "You have initialized an object!"
  end

  after_find do |user|
    puts "You have found an object!"
  end
end
----

[source,irb]
----
>> User.new
You have initialized an object!
=> #<User id: nil>

>> User.first
You have found an object!
You have initialized an object!
=> #<User id: 1>
----

[[after-touch]]
==== `after_touch` 回调

当我们在 Active Record 对象上调用 `touch` 方法时，会调用 `after_touch` 回调。

[[source,ruby]]
----
class User < ApplicationRecord
  after_touch do |user|
    puts "You have touched an object"
  end
end
----

[source,irb]
----
>> u = User.create(name: 'Kuldeep')
=> #<User id: 1, name: "Kuldeep", created_at: "2013-11-25 12:17:49", updated_at: "2013-11-25 12:17:49">

>> u.touch
You have touched an object
=> true
----

`after_touch` 回调可以和 `belongs_to` 一起使用：

[source,ruby]
----
class Employee < ApplicationRecord
  belongs_to :company, touch: true
  after_touch do
    puts 'An Employee was touched'
  end
end

class Company < ApplicationRecord
  has_many :employees
  after_touch :log_when_employees_or_company_touched

  private
  def log_when_employees_or_company_touched
    puts 'Employee/Company was touched'
  end
end
----

[source,irb]
----
>> @employee = Employee.last
=> #<Employee id: 1, company_id: 1, created_at: "2013-11-25 17:04:22", updated_at: "2013-11-25 17:05:05">

# triggers @employee.company.touch
>> @employee.touch
Employee/Company was touched
An Employee was touched
=> true
----

[[running-callbacks]]
=== 调用回调

下面这些方法会触发回调：

* `create`
* `create!`
* `decrement!`
* `destroy`
* `destroy!`
* `destroy_all`
* `increment!`
* `save`
* `save!`
* `save(validate: false)`
* `toggle!`
* `update_attribute`
* `update`
* `update!`
* `valid?`

此外，下面这些查找器方法会触发 `after_find` 回调：

* `all`
* `first`
* `find`
* `find_by`
* `find_by_*`
* `find_by_*!`
* `find_by_sql`
* `last`

每次初始化类的新对象时都会触发 `after_initialize` 回调。

NOTE: `find_by_*` 和 `find_by_*!` 方法是为每个属性自动生成的动态查找器。关于动态查找器的更多介绍，请参阅 <<active_record_querying#dynamic-finders>> 一节。

[[skipping-callbacks]]
=== 跳过回调

和验证一样，我们可以跳过回调。使用下面这些方法可以跳过回调：

* `decrement`
* `decrement_counter`
* `delete`
* `delete_all`
* `increment`
* `increment_counter`
* `toggle`
* `touch`
* `update_column`
* `update_columns`
* `update_all`
* `update_counters`

请慎重地使用这些方法，因为有些回调包含了重要的业务规则和程序逻辑，在不了解潜在影响的情况下就跳过回调，可能导致无效数据。

[[halting-execution]]
=== 停止执行

回调在模型中注册后，将被加入队列等待执行。这个队列包含了所有模型的验证、已注册的回调和将要执行的数据库操作。

整个回调链包装在一个事务中。如果任何一个 `before` 回调方法返回 `false` 或引发异常，整个回调链就会停止执行，同时发出 `ROLLBACK` 消息来回滚事务；而 `after` 回调方法只能通过引发异常来达到相同效果。

WARNING: 当回调链停止后，Rails 会重新抛出除了 `ActiveRecord::Rollback` 和 `ActiveRecord::RecordInvalid` 之外的其他异常。这可能导致那些预计 `save` 和 `update_attributes` 这类方法（通常返回 `true` 或 `false` ）不会引发异常的代码出错。

[[relational-callbacks]]
=== 关联回调
