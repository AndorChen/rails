[[action-view-overview]]
== Action View 概述
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
读完本文后，你将学会：

* Action View 是什么，如何在 Rails 中使用 Action View。
* 模板、局部视图和布局的最佳使用方法。
* Action View 提供了哪些帮助方法，如何编写自己的帮助方法。
* 如何使用本地化视图。
--

[[what-is-action-view]]
=== Action View 是什么

在Rails中，Web 请求由 Action Controller（请参阅 <<action_controller_overview>>）和 Action View 处理。通常，Action Controller 参与和数据库的通信，并在需要时执行 CRUD 操作，然后由 Action View 负责编译响应。

Action View 模板使用混合了 HTML 标签的嵌入式 Ruby 语言编写。为了避免样板代码把模板弄乱，Action View 提供了许多帮助方法，用于创建表单、日期和字符串等常用组件。随着开发的深入，为程序添加新的帮助方法也很容易。

NOTE: Action View 的某些特性与 Active Record 有关，但这并不意味着 Action View 依赖 Active Record。Action View 是独立的软件包，可以和任何类型的 Ruby 库一起使用。

[[using-action-view-with-rails]]
=== 在 Rails 中使用 Action View

在 `app/views` 文件夹中，每个控制器都有一个对应的文件夹，其中保存了控制器对应视图的模板文件。这些模板文件用于显示每个控制器动作产生的视图。

在 Rails 中使用脚手架生成器来新建资源时，默认会执行下面的操作：

----
$ bin/rails generate scaffold article
      [...]
      invoke  scaffold_controller
      create    app/controllers/articles_controller.rb
      invoke    erb
      create      app/views/articles
      create      app/views/articles/index.html.erb
      create      app/views/articles/edit.html.erb
      create      app/views/articles/show.html.erb
      create      app/views/articles/new.html.erb
      create      app/views/articles/_form.html.erb
      [...]
----

在上面的输出结果中我们可以看到 Rails 中视图的命名约定。通常，视图和对应的控制器动作共享名称。例如，`articles_controller.rb` 控制器文件中的 `index` 动作对应 `app/views/articles` 文件夹中的 `index.html.erb` 视图文件。返回客户端的完整 HTML 由 ERB 视图文件和包装它的布局文件，以及视图可能引用的所有局部视图文件组成。后文会详细介绍这三种文件。

[[templates-partials-and-layouts]]
=== 模板、局部视图和布局

前面说过，最后输出的 HTML 由模板、局部视图和布局这三种 Rails 元素组成。下面分别进行简要介绍。

[[templates]]
==== 模板

Action View 模板可以用多种方式编写。扩展名是 `.erb` 的模板文件混合使用 ERB（嵌入式 Ruby）和 HTML 编写，扩展名是 `.builder` 的模板文件使用 `Builder::XmlMarkup` 库编写。

Rails 支持多种模板系统，并使用文件扩展名加以区分。例如，使用 ERB 模板系统的 HTML 文件的扩展名是 `.html.erb`。

[[erb]]
===== ERB 模板

在 ERB 模板中，可以使用 `<% %>` 和 `<%= %>` 标签来包含 Ruby 代码。`<% %>` 标签用于执行不返回任何内容的 Ruby 代码，例如条件、循环或块，而 `<%= %>` 标签用于输出 Ruby 代码的执行结果。

下面是一个循环输出名称的例子：

[source,irb]
----
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
<% end %>
----

在上面的代码中，使用普通嵌入标签（`<% %>`）建立循环，使用输出嵌入标签（`<%= %>`）插入名称。请注意，这种用法不仅仅是建议用法（而是必须这样使用），因为在 ERB 模板中，普通的输出方法，例如 `print` 和 `puts` 方法，无法正常渲染。因此，下面的代码是错误的：

[source,irb]
----
<%# WRONG %>
Hi, Mr. <% puts "Frodo" %>
----

要想删除前导和结尾空格，可以把 `<% %>` 标签替换为 `<%- -%>` 标签。

[[builder]]
===== Builder 模板

和 ERB 模板相比，Builder 模板更加按部就班，常用于生成 XML 内容。在扩展名为 `.builder` 的模板中，可以直接使用名为 `xml` 的 XmlMarkup 对象。

下面是一些简单的例子：

[source,ruby]
----
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "http://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
----

上面的代码会生成下面的 XML：

[source,xml]
----
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="http://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
----

带有块的方法会作为 XML 标签处理，块中的内容会嵌入这个标签中。例如：

[source,ruby]
----
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
----

上面的代码会生成下面的 XML：

[source,xml]
----
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
----

下面是 Basecamp 网站用于生成 RSS 的完整的实际代码：

[source,ruby]
----
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
----

[[jbuilder]]
===== Jbuilder 模板系统

link:https://github.com/rails/jbuilder[Jbuilder] 是由 Rails 团队维护并默认包含在 Rails Gemfile 中的 gem。它类似 Builder，但用于生成 JSON，而不是 XML。

如果你的程序中没有 Jbuilder 这个 gem，可以把下面的代码添加到 Gemfile：

[source,ruby]
----
gem 'jbuilder'
----

在扩展名为 `.jbuilder` 的模板中，可以直接使用名为 `json` 的 Jbuilder 对象。

下面是一个简单的例子：

[source,ruby]
----
json.name("Alex")
json.email("alex@example.com")
----

上面的代码会生成下面的 JSON：

[source,json]
----
{
  "name": "Alex",
  "email": "alex@example.com"
}
----

关于 Jbuilder 模板的更多例子和信息，请参阅 link:https://github.com/rails/jbuilder#jbuilder[Jbuilder 文档]。

[[template-caching]]
===== 模板缓存

默认情况下，Rails 会把所有模板分别编译为方法，以便进行渲染。在开发环境中，当我们修改了模板时，Rails 会检查文件的修改时间并自动重新编译。

[[partials]]
==== 局部视图
