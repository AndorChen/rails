[[action-view-overview]]
== Action View 概述
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
读完本文后，你将学会：

* Action View 是什么，如何在 Rails 中使用 Action View。
* 模板、局部视图和布局的最佳使用方法。
* Action View 提供了哪些帮助方法，如何编写自己的帮助方法。
* 如何使用本地化视图。
--

[[what-is-action-view]]
=== Action View 是什么

在Rails中，Web 请求由 Action Controller（请参阅 <<action_controller_overview>>）和 Action View 处理。通常，Action Controller 参与和数据库的通信，并在需要时执行 CRUD 操作，然后由 Action View 负责编译响应。

Action View 模板使用混合了 HTML 标签的嵌入式 Ruby 语言编写。为了避免样板代码把模板弄乱，Action View 提供了许多帮助方法，用于创建表单、日期和字符串等常用组件。随着开发的深入，为程序添加新的帮助方法也很容易。

NOTE: Action View 的某些特性与 Active Record 有关，但这并不意味着 Action View 依赖 Active Record。Action View 是独立的软件包，可以和任何类型的 Ruby 库一起使用。

[[using-action-view-with-rails]]
=== 在 Rails 中使用 Action View

在 `app/views` 文件夹中，每个控制器都有一个对应的文件夹，其中保存了控制器对应视图的模板文件。这些模板文件用于显示每个控制器动作产生的视图。

在 Rails 中使用脚手架生成器来新建资源时，默认会执行下面的操作：

----
$ bin/rails generate scaffold article
      [...]
      invoke  scaffold_controller
      create    app/controllers/articles_controller.rb
      invoke    erb
      create      app/views/articles
      create      app/views/articles/index.html.erb
      create      app/views/articles/edit.html.erb
      create      app/views/articles/show.html.erb
      create      app/views/articles/new.html.erb
      create      app/views/articles/_form.html.erb
      [...]
----

在上面的输出结果中我们可以看到 Rails 中视图的命名约定。通常，视图和对应的控制器动作共享名称。例如，`articles_controller.rb` 控制器文件中的 `index` 动作对应 `app/views/articles` 文件夹中的 `index.html.erb` 视图文件。返回客户端的完整 HTML 由 ERB 视图文件和包装它的布局文件，以及视图可能引用的所有局部视图文件组成。后文会详细介绍这三种文件。

[[templates-partials-and-layouts]]
=== 模板、局部视图和布局

前面说过，最后输出的 HTML 由模板、局部视图和布局这三种 Rails 元素组成。下面分别进行简要介绍。

[[templates]]
==== 模板

Action View 模板可以用多种方式编写。扩展名是 `.erb` 的模板文件混合使用 ERB（嵌入式 Ruby）和 HTML 编写，扩展名是 `.builder` 的模板文件使用 `Builder::XmlMarkup` 库编写。

Rails 支持多种模板系统，并使用文件扩展名加以区分。例如，使用 ERB 模板系统的 HTML 文件的扩展名是 `.html.erb`。

[[erb]]
===== ERB 模板

在 ERB 模板中，可以使用 `<% %>` 和 `<%= %>` 标签来包含 Ruby 代码。`<% %>` 标签用于执行不返回任何内容的 Ruby 代码，例如条件、循环或块，而 `<%= %>` 标签用于输出 Ruby 代码的执行结果。

下面是一个循环输出名称的例子：

[source,irb]
----
<h1>Names of all the people</h1>
<% @people.each do |person| %>
  Name: <%= person.name %><br>
<% end %>
----

在上面的代码中，使用普通嵌入标签（`<% %>`）建立循环，使用输出嵌入标签（`<%= %>`）插入名称。请注意，这种用法不仅仅是建议用法（而是必须这样使用），因为在 ERB 模板中，普通的输出方法，例如 `print` 和 `puts` 方法，无法正常渲染。因此，下面的代码是错误的：

[source,irb]
----
<%# WRONG %>
Hi, Mr. <% puts "Frodo" %>
----

要想删除前导和结尾空格，可以把 `<% %>` 标签替换为 `<%- -%>` 标签。

[[builder]]
===== Builder 模板

和 ERB 模板相比，Builder 模板更加按部就班，常用于生成 XML 内容。在扩展名为 `.builder` 的模板中，可以直接使用名为 `xml` 的 XmlMarkup 对象。

下面是一些简单的例子：

[source,ruby]
----
xml.em("emphasized")
xml.em { xml.b("emph & bold") }
xml.a("A Link", "href" => "http://rubyonrails.org")
xml.target("name" => "compile", "option" => "fast")
----

上面的代码会生成下面的 XML：

[source,xml]
----
<em>emphasized</em>
<em><b>emph &amp; bold</b></em>
<a href="http://rubyonrails.org">A link</a>
<target option="fast" name="compile" />
----

带有块的方法会作为 XML 标签处理，块中的内容会嵌入这个标签中。例如：

[source,ruby]
----
xml.div {
  xml.h1(@person.name)
  xml.p(@person.bio)
}
----

上面的代码会生成下面的 XML：

[source,xml]
----
<div>
  <h1>David Heinemeier Hansson</h1>
  <p>A product of Danish Design during the Winter of '79...</p>
</div>
----

下面是 Basecamp 网站用于生成 RSS 的完整的实际代码：

[source,ruby]
----
xml.rss("version" => "2.0", "xmlns:dc" => "http://purl.org/dc/elements/1.1/") do
  xml.channel do
    xml.title(@feed_title)
    xml.link(@url)
    xml.description "Basecamp: Recent items"
    xml.language "en-us"
    xml.ttl "40"

    for item in @recent_items
      xml.item do
        xml.title(item_title(item))
        xml.description(item_description(item)) if item_description(item)
        xml.pubDate(item_pubDate(item))
        xml.guid(@person.firm.account.url + @recent_items.url(item))
        xml.link(@person.firm.account.url + @recent_items.url(item))
        xml.tag!("dc:creator", item.author_name) if item_has_creator?(item)
      end
    end
  end
end
----

[[jbuilder]]
===== Jbuilder 模板系统

link:https://github.com/rails/jbuilder[Jbuilder] 是由 Rails 团队维护并默认包含在 Rails Gemfile 中的 gem。它类似 Builder，但用于生成 JSON，而不是 XML。

如果你的程序中没有 Jbuilder 这个 gem，可以把下面的代码添加到 Gemfile：

[source,ruby]
----
gem 'jbuilder'
----

在扩展名为 `.jbuilder` 的模板中，可以直接使用名为 `json` 的 Jbuilder 对象。

下面是一个简单的例子：

[source,ruby]
----
json.name("Alex")
json.email("alex@example.com")
----

上面的代码会生成下面的 JSON：

[source,json]
----
{
  "name": "Alex",
  "email": "alex@example.com"
}
----

关于 Jbuilder 模板的更多例子和信息，请参阅 link:https://github.com/rails/jbuilder#jbuilder[Jbuilder 文档]。

[[template-caching]]
===== 模板缓存

默认情况下，Rails 会把所有模板分别编译为方法，以便进行渲染。在开发环境中，当我们修改了模板时，Rails 会检查文件的修改时间并自动重新编译。

[[partials]]
==== 局部视图

局部视图模板，通常直接称为“局部视图”，会把渲染过程分成多个更容易管理的部分。局部视图从模板中提取代码片断并保存在独立的文件中，然后在模板中重用这些代码片断。

[[naming-partials]]
===== 局部视图的名称

在视图中我们使用 `render` 方法来渲染局部视图：

[source,erb]
----
<%= render "menu" %>
----

在渲染视图的过程中，上面的代码会渲染 `_menu.html.erb` 局部视图文件。请注意前导的下划线：局部视图的文件名总是以下划线开头，以便和普通视图文件区分开来，但在引用局部视图时不写下划线。从其他文件夹中加载局部视图文件时同样遵守这一规则：

[source,erb]
----
<%= render "shared/menu" %>
----

上面的代码会加载 `app/views/shared/_menu.html.erb` 局部视图文件。

[[using-partials-to-simplify-views]]
===== 使用局部视图来简化视图

使用局部视图的一种方式是把它们看作子程序，也就是把细节内容从视图中移出来，这样会使视图更容易理解。例如：

[source,erb]
----
<%= render "shared/ad_banner" %>

<h1>Products</h1>

<p>Here are a few of our fine products:</p>
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>

<%= render "shared/footer" %>
----

在上面的代码中，`_ad_banner.html.erb` 和 `_footer.html.erb` 局部视图可以在多个页面中使用。当我们专注于实现某个页面时，不必关心这些局部视图的细节。

[[render-without-partial-and-locals-options]]
===== 不使用 `partial` 和 `locals` 选项进行渲染

在前面的例子中，`render` 方法有两个选项：`partial` 和 `locals`。如果一共只有这两个选项，那么可以跳过不写。例如，下面的代码：

[source,erb]
----
<%= render partial: "product", locals: { product: @product } %>
----

可以改写为：

[source,erb]
----
<%= render "product", product: @product %>
----

[[the-as-and-object-options]]
===== `as` 和 `object` 选项

默认情况下，`ActionView::Partials::PartialRenderer` 的对象储存在和模板同名的局部变量中。因此，我们可以扩展下面的代码：

[source,erb]
----
<%= render partial: "product" %>
----

在 `_product` 局部视图中，我们可以通过局部变量 `product` 引用 `@product` 实例变量：

[source,erb]
----
<%= render partial: "product", locals: { product: @product } %>
----

`as` 选项用于为局部变量指定不同的名称。例如，把局部变量的名称由 `product` 改为 `item`：

[source,erb]
----
<%= render partial: "product", as: "item" %>
----

`object` 选项用于直接指定想要在局部视图中使用的对象，常用于模板对象位于其他地方（例如位于其他实例变量或局部变量中）的情况。例如，下面的代码：

[source,erb]
----
<%= render partial: "product", locals: { product: @item } %>
----

可以改写为：

[source,erb]
----
<%= render partial: "product", object: @item %>
----

`object` 和 `as` 选项还可一起使用：

[source,erb]
----
<%= render partial: "product", object: @item, as: "item" %>
----

[[rendering-collections]]
===== 集合的渲染

模板经常需要遍历集合并使用集合的每个元素分别渲染子模板。在 Rails 中我们只需一行代码就可以完成这项工作。例如，下面这段渲染产品局部视图的代码：

[source,erb]
----
<% @products.each do |product| %>
  <%= render partial: "product", locals: { product: product } %>
<% end %>
----

可以改写为：

[source,erb]
----
<%= render partial: "product", collection: @products %>
----

当使用集合来渲染局部视图时，在每个局部视图实例中，都可以使用和局部视图同名的局部变量来访问集合中的元素。在本例中，局部视图是 `_product`，在这个局部视图中我们可以通过 `product` 局部变量来访问用于渲染局部视图的集合中的元素。

渲染集合还有一个简易写法。假设 `@products` 是 `Product` 的实例的集合，上面的代码可以改写为：

[source,erb]
----
<%= render @products %>
----

Rails 会根据集合中的模型名来确定应该使用哪个局部视图，在本例中模型名是 `Product`。实际上，我们甚至可以使用这种简易写法来渲染由不同模型实例组成的集合，Rails 会为集合中的每个元素选择适当的局部视图。

[[spacer-templates]]
===== 间隔模板

我们还可以使用 `:spacer_template` 选项来指定第二个局部视图（也就是间隔模板），在渲染第一个局部视图（也就是主局部视图）的两个实例之间会渲染这个间隔模板:

[source,erb]
----
<%= render partial: @products, spacer_template: "product_ruler" %>
----

上面的代码会在两个 `_product` 局部视图（主局部视图）之间渲染 `_product_ruler` 局部视图（间隔模板）。

[[layouts]]
==== 布局

布局是渲染 Rails 控制器返回结果时使用的公共视图模板。通常，Rails 程序中会包含多个视图用于渲染不同页面。例如，网站中用户登录后页面的布局，营销或销售页面的布局。用户登录后页面的布局可以包含在多个控制器动作中出现的顶级导航。SaaS 程序的销售页面布局可以包含指向“定价”和“联系我们”页面的顶级导航。不同布局可以有不同的外观和感觉。关于布局的更多介绍，请参阅 <<layouts_and_rendering>> 一文。

[[partial-layout]]
=== 局部布局
