[[getting-started-with-rails]]
== Rails 入门
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
本文介绍如何开始使用 Ruby on Rails。

读完后，你将学会：

* 如何安装 Rails，创建 Rails 程序，如何连接数据库。
* Rails 程序的基本文件结构。
* MVC（模型，视图，控制器）和 REST 架构的基本原理。
* 如何快速生成 Rails 程序骨架。
--

[[guide-assumptions]]
=== 前提条件

本文针对想从零开始开发 Rails 程序的初学者，不要求 Rails 使用经验。不过，为了能顺利阅读，还是需要事先安装好一些软件：

* link:https://www.ruby-lang.org/en/downloads[Ruby] 2.2.2 及以上版本
* link:http://rubyinstaller.org/downloads/[开发工具箱] 的正确版本（针对 Windows 用户）
* 包管理工具 link:https://rubygems.org/[RubyGems]，随 Ruby 预装。想深入了解 RubyGems，请参阅 link:http://guides.rubygems.org/[RubyGems 指南]
* link:https://www.sqlite.org/[SQLite3 数据库]

Rails 是使用 Ruby 语言开发的 Web 应用程序框架。如果之前没接触过 Ruby，会感到直接学习 Rails 的学习曲线很陡。这里提供几个学习 Ruby 的在线资源列表：

* link:https://www.ruby-lang.org/en/documentation/[Ruby 语言官方网站]
* link:https://github.com/vhf/free-programming-books/blob/master/free-programming-books.md#ruby[免费编程图书列表]

需要注意的是，有些资源虽然很好，但针对的是 Ruby 1.8 甚至 1.6 这些老版本，因此不涉及一些 Rails 日常开发的常见语法。

[[what-is-rails]]
=== Rails 是什么？

Rails 是使用 Ruby 语言编写的 Web 应用程序开发框架，目的是通过解决快速开发中的共性问题，简化 Web 应用程序开发。与其他编程语言和框架相比，使用 Rails 只需编写更少代码就能实现更多功能。有经验的 Rails 程序员常说，Rails 让 Web 应用程序开发变得更有趣。

Rails 有自己的设计原则，认为问题总有最好的解决方法，并且有意识地通过设计来鼓励用户使用最好的解决方法，而不是其他替代方案。一旦掌握了“Rails 之道”，就可能获得生产力的巨大提升。在 Rails 开发中，如果不改变使用其他编程语言时养成的习惯，总想应用原有的设计模式，开发体验可能就不那么让人愉快了。

Rails 哲学包含两大指导思想：

* 不要自我重复（DRY）： DRY 是软件开发中的一个原则，意思是“系统中的每个功能都要具有单一、准确、可信的实现。”。不重复表述同一件事，写出的代码才能更易维护，更具扩展性，也更不容易出问题。
* 多约定，少配置： Rails 为 Web 应用程序的大多数需求都提供了最好的解决方法，并且默认使用这些约定，而不是在长长的配置文件中设置每个细节。

[[creating-a-new-rails-project]]
=== 创建 Rails 项目

阅读本文的最佳方法是一步一步跟着操作。所有这些步骤对于运行示例程序都是必不可少的，同时也不需要更多的代码或步骤。

通过学习本文，你将学会如何创建一个名为 Blog 的 Rails 项目，这是一个非常简单的博客。在动手开发之前，请确保已经安装了 Rails。

TIP: 文中的示例代码使用 UNIX 风格的命令行提示符 $，如果你的命令行提示符是自定义的看起来可能会不一样。在 Windows 中，命令行提示符可能类似 `c:\source_code>``。

[[installing-rails]]
==== 安装 Rails

打开命令行：在 Mac OS X 中打开 Terminal.app，在 Windows 中要在开始菜单中选择“运行”并输入“cmd.exe”。本文中所有以 $ 开头的代码，都应该在命令行中执行。首先确认是否安装了 Ruby 的最新版本：

----
$ ruby -v
ruby 2.3.0p0
----

TIP: 有很多工具可以帮助你快速地在系统中安装 Ruby 和 Ruby on Rails。Windows 用户可以使用 link:http://railsinstaller.org/[Rails Installer]，Mac OS X 用户可以使用 link:https://github.com/tokaido/tokaidoapp[Tokaido]。更多操作系统中的安装方法请访问 link:https://www.ruby-lang.org/en/documentation/installation/[ruby-lang.org]。

很多类 UNIX 系统都预装了版本较新的 SQLite3。在 Windows 中，通过 Rails Installer 安装 Rails 会同时安装 SQLite3。其他操作系统中 SQLite3 的安装方法请参阅 link:https://www.sqlite.org/[SQLite3 官网]。接下来，确认 SQLite3 是否在 PATH 中：

----
$ sqlite3 --version
----

执行结果应该显示 SQLite3 的版本号。

安装 Rails，请使用 RubyGems 提供的 `gem install` 命令：

----
$ gem install rails
----

执行下面的命令来确认所有软件是否都已正确安装：

----
$ rails --version
----

如果执行结果类似 `Rails 5.0.0`，那么就可以继续往下读了。


[[creating-the-blog-application]]
==== 创建 Blog 程序

Rails 提供了许多名为“生成器”的脚本，这些脚本可以为特定任务生成所需的全部文件，从而简化开发。其中包括新程序生成器，这个脚本用于创建 Rails 程序骨架，避免了手动编写基础代码。

要使用新程序生成器，请打开终端，进入具有写权限的文件夹，输入：

----
$ rails new blog
----

这个命令会在文件夹 `blog` 中创建名为 Blog 的 Rails 程序，然后执行 `bundle install` 命令安装 Gemfile 中列出的 gem 及其依赖关系。

TIP: 执行 `rails new -h` 命令可以查看新程序生成器的所有命令行选项。

创建 blog 程序后，进入该文件夹：

----
$ cd blog
----

`blog` 文件夹中有许多自动生成的文件和文件夹，这些文件和文件夹组成了 Rails 程序的结构。本文涉及的大部分工作都在 app 文件夹中完成。下面简单介绍一下这些用新程序生成器默认选项生成的文件和文件夹的功能：

|===
| 文件/文件夹 | 作用

| `app/`
| 包含程序的控制器、模型、视图、帮助方法、邮件程序和静态资源文件。这个文件夹是本文剩余内容关注的重点。

| `bin/`
| 包含用于启动程序的 rails 脚本，以及用于安装、更新、部署或运行程序的其他脚本。

| `config/`
| 配置程序的路由、数据库等。详情请参阅“link:http://guides.rubyonrails.org/configuring.html[配置 Rails 程序]”。

| `config.ru`
| 基于 Rack 的服务器所需的 Rack 配置，用于启动程序。

| `db/`
| 包含当前数据库的模式，以及数据库迁移文件。

| `Gemfile`, `Gemfile.lock`
| 这两个文件用于指定 Rails 程序所需的 gem 的依赖关系。Bundler gem 需要用到这两个文件。关于 Bundler 的更多介绍，请访问 link:http://bundler.io/[Bundler 官网]。

| `lib/`
| 程序的扩展模块。

| `log/`
| 程序日志文件。

| `public/`
| 仅有的可以直接从外部访问的文件夹，包含静态文件和编译后的静态资源文件。

| `Rakefile`
| 定位并加载可在命令行中执行的任务。这些任务在 Rails 的各个组件中定义。如果要添加自定义任务，请不要修改 Rakefile，真接把自定义任务保存在 `lib/tasks` 文件夹中即可。

| `README.md`
| 程序的自述文件，说明程序的用途、安装方法等。

| `test/`
| 单元测试、夹具和其他测试装置。详情请参阅“link:http://guides.rubyonrails.org/testing.html[测试 Rails 程序]”。

| `tmp/`
| 临时文件（如缓存和 PID 文件）。

| `vendor/`
| 包含第三方代码，如第三方 gem。 |
|===

[[hello-rails]]
=== Hello, Rails!

首先，让我们快速地在页面中添加一些文字。为了访问页面，需要运行 Rails 程序服务器（即 Web 服务器）。

[[starting-up-the-web-server]]
==== 启动 Web 服务器

实际上这个 Rails 程序已经可以正常运行了。要访问程序，需要在开发电脑上启动 Web 服务器。请在 `blog` 文件夹中执行下面的命令：

----
$ bin/rails server
----

TIP: Windows 用户需要把 `bin` 文件夹下的脚本文件直接传递给 Ruby 解析器，例如 `ruby bin\rails server`。

TIP: 编译 CoffeeScript 和 压缩 JavaScript 静态资源文件需要 JavaScript 运行时，如果没有运行时，在压缩静态资源文件时就会报错，提示没有 `execjs`。Mac OS X 和 Windows 一般都提供了 JavaScript 运行时。在创建 Rails 程序的 Gemfile 中，`therubyracer` gem 被注释掉了，如果需要使用这个 gem，请去掉注释。对于 JRuby 用户，推荐使用 `therubyrhino` 这个运行时，在 JRuby 中创建 Rails 程序的 Gemfile 中默认包含了这个 gem。要查看 Rails 支持的所有运行时，请参阅 link:https://github.com/rails/execjs#readme[ExecJS]。

上述命令会启动 Puma，这是 Ruby 内置的 Web 服务器。要查看运行中的程序，请打开浏览器窗口，访问 link:$$http://localhost:3000$$[]。这时应该看到默认的 Rails 欢迎页面：

[[rails-welcome]]
.默认的 Rails 欢迎页面
image::rails_welcome.png[默认的 Rails 欢迎页面]

TIP: 要停止 Web 服务器，请在终端中按 Ctrl+C 键。服务器停止后命令行提示符会重新出现。在大多数类 Unix 系统中，包括 Mac OS X，命令行提示符是 $ 符号。在开发模式中，一般情况下无需重启服务器，服务器会自动加载修改后的文件。

欢迎页面是创建 Rails 程序的冒烟测试，看到这个页面就表示程序已经正确配置，能够正常工作了。

[[say-hello-rails]]
==== 显示“Hello, Rails!”

要让 Rails 显示“Hello, Rails!”，需要创建__控制器__和__视图__。

控制器接受向应用程序发起的特定访问请求。__路由__决定哪些访问请求被哪些控制器接受。一般情况下，一个控制器会对应多个路由，不同路由对应不同__动作__。动作搜集数据并把数据提供给视图。

视图以人类能看懂的格式显示数据。有一点要特别注意，数据是在__控制器__而不是视图中获取的，视图只是显示数据。默认情况下，视图模板使用 eRuby（嵌入式 Ruby）语言编写，经由 Rails 解析后，再发送给用户。

可以用控制器生成器来创建控制器。下面的命令告诉控制器生成器创建一个包含“index”动作的“Welcome”控制器：

----
$ bin/rails generate controller Welcome index
----

上述命令让 Rails 生成了多个文件和一个路由：

----
create  app/controllers/welcome_controller.rb
 route  get 'welcome/index'
invoke  erb
create    app/views/welcome
create    app/views/welcome/index.html.erb
invoke  test_unit
create    test/controllers/welcome_controller_test.rb
invoke  helper
create    app/helpers/welcome_helper.rb
invoke  assets
invoke    coffee
create      app/assets/javascripts/welcome.coffee
invoke    scss
create      app/assets/stylesheets/welcome.scss
----

其中最重要的文件是控制器和视图，控制器位于 `app/controllers/welcome_controller.rb` 文件 ，视图位于 `app/views/welcome/index.html.erb` 文件 。

在文本编辑器中打开 `app/views/welcome/index.html.erb` 文件，删除所有代码，然后添加下面的代码：

----
<h1>Hello, Rails!</h1>
----

[[setting-the-application-home-page]]
==== 设置程序主页

现在我们已经创建了控制器和视图，还需要告诉 Rails 何时显示“Hello, Rails!”，我们希望在访问根地址  link:$$http://localhost:3000$$[] 时显示。目前根地址显示的还是默认的 Rails 欢迎页面。

接下来需要告诉 Rails 真正的主页在哪里。

在编辑器中打开 `config/routes.rb` 文件。

[source,ruby]
----
Rails.application.routes.draw do
  get 'welcome/index'

  # For details on the DSL available within this file, see http://guides.rubyonrails.org/routing.html
end
----

这是程序的路由文件，使用特殊的 DSL（domain-specific language，领域专属语言）编写，告诉 Rails 把访问请求发往哪个控制器和动作。编辑这个文件，添加一行代码 `root 'welcome#index'`，此时文件内容应该变成下面这样：

[source,ruby]
----
Rails.application.routes.draw do
  get 'welcome/index'

  root 'welcome#index'
end
----

`root 'welcome#index'` 告诉 Rails 对根路径的访问请求应该发往 welcome 控制器的 index 动作，`get 'welcome/index'` 告诉 Rails 对 link:$$http://localhost:3000/welcome/index$$[] 的访问请求应该发往 welcome 控制器的 index 动作。后者是之前使用控制器生成器创建控制器（`bin/rails generate controller Welcome index`）时自动生成的。

如果在生成控制器时停止了服务器，请再次启动服务器（`bin/rails server`），然后在浏览器中访问  link:$$http://localhost:3000$$[]。我们会看到之前添加到 `app/views/welcome/index.html.erb` 文件 的“Hello, Rails!”信息，这说明新定义的路由确实把访问请求发往了 `WelcomeController` 的 `index` 动作，并正确渲染了视图。

TIP: 关于路由的更多介绍，请参阅“link:http://guides.rubyonrails.org/routing.html[Rails 路由全解]”一文。

[[getting-up-and-running]]
=== 启动并运行起来

前文已经介绍了如何创建控制器、动作和视图，接下来我们要创建一些更具实用价值的东西。

在 Blog 程序中创建一个__资源__。资源是一个术语，表示一系列类似对象的集合，如文章、人或动物。资源中的项目可以被创建、读取、更新和删除，这些操作简称 __CRUD__ 操作（Create, Read, Update, Delete）。

Rails 提供了 `resources` 方法，用于声明标准 REST 架构的资源。把 article 资源添加到 `config/routes.rb` 文件，此时文件内容应该变成下面这样：

[source,ruby]
----
Rails.application.routes.draw do

  resources :articles

  root 'welcome#index'
end
----

执行 `bin/rails routes` 命令，可以看到所有标准 REST 动作都具有对应路由。输出结果中各列的意义稍后会作说明，现在只需注意  Rails 从 article 的单数形式推导出了它的复数形式，并进行了合理使用。

----
$ bin/rails routes
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
 new_article GET    /articles/new(.:format)      articles#new
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index
----

下一节，我们要为程序添加新建文章和查看文章的功能。这两个操作分别对应于 CRUD 的“C”和“R”：创建和读取。下面是用于新建文章的表单：

[[new-article]]
.用于新建文章的表单
image::new_article.png[用于新建文章的表单]

表单看起来很简陋，不过没关系，之后我们再来美化。

[[laying-down-the-ground-work]]
==== 打地基

首先，程序需要一个页面用于新建文章，`/articles/new` 是个不错的选择。相关路由之前已经定义过了，可以直接访问。打开  link:$$http://localhost:3000/articles/new$$[]，会看到下面的路由错误：

[[routing-error-no-controller]]
.路由错误，常量 ArticlesController 未初始化
image::routing_error_no_controller.png[路由错误，常量 ArticlesController 未初始化]

产生错误的原因是，用于处理该访问请求的控制器还没有定义。解决问题的方法很简单：创建 `ArticlesController` 控制器。执行下面的命令：

----
$ bin/rails generate controller Articles
----

打开刚刚生成的 `app/controllers/articles_controller.rb` 文件，会看到一个空的控制器：

[source,ruby]
----
class ArticlesController < ApplicationController
end
----

控制器实际上只是一个继承自 `ApplicationController` 的类。接在来要在这个类中定义的方法也就是控制器的动作。这些动作针对文章执行 CRUD 操作。

TIP: 在 Ruby 中，有 `public`、`private` 和 `protected` 三种方法，其中只有 `public` 方法才能作为控制器的动作。详情请参阅 link:http://www.ruby-doc.org/docs/ProgrammingRuby/[Programming Ruby] 一书。

现在刷新 link:$$http://localhost:3000/articles/new$$[]，会看到一个新错误：

[[unknown-action-new-for-articles]]
.未知动作，在 ArticlesController 中找不到 new 动作
image::unknown_action_new_for_articles.png[未知动作，在 ArticlesController 中找不到 new 动作]

这个错误的意思是，Rails 在刚刚生成的 `ArticlesController` 中找不到 new 动作。这是因为在 Rails 中生成控制器时，如果不指定想要的动作，生成的控制器就会是空的。

在控制器中手动定义动作，只需要定义一个新方法。打开 `app/controllers/articles_controller.rb` 文件，在 `ArticlesController` 类中定义 `new` 方法，此时控制器应该变成下面这样：

[source,ruby]
----
class ArticlesController < ApplicationController
  def new
  end
end
----

在 `ArticlesController` 中定义 `new` 方法后，再次刷新 link:$$http://localhost:3000/articles/new$$[]，会看到另一个错误：

[[template-is-missing-articles-new]]
.未知格式，缺少对应模板
image::template_is_missing_articles_new.png[未知格式，缺少对应模板]

产生错误的原因是，Rails 要求这样的常规动作有用于显示数据的对应视图。如果没有视图可用，Rails就会引发异常。

上图中下面的几行都被截断了，下面是完整信息：

____
ArticlesController#new is missing a template for this request format and variant. request.formats: ["text/html"] request.variant: [] NOTE! For XHR/Ajax or API requests, this action would normally respond with 204 No Content: an empty white screen. Since you're loading it in a web browser, we assume that you expected to actually render a template, not… nothing, so we're showing an error to be extra-clear. If you expect 204 No Content, carry on. That's what you'll get from an XHR or API request. Give it a shot.
____

内容还真不少！让我们快速浏览一下，看看各部分是什么意思。

第一部分说明缺少哪个模板，这里缺少的是 `articles/new` 模板。Rails 首先查找这个模板，如果找不到再查找 `application/new` 模板。之所以会查找后面这个模板，是因为 `ArticlesController` 继承自 `ApplicationController`。

信息的下一部分包含一个 Hash。Hash 的 `:locale` 键说明模板应该以哪国语言解析，默认是英语（“en”）。Hash 的 `:formats` 键说明响应使用的模板格式，默认是 `:html`，因此 Rails 会查找 HTML 模板。Hash 的 `:handlers` 键说明渲染模板使用的模板处理器，对于 HTML 模板通常使用 `:erb`，XML 模板使用 `:builder`，JavaScript 模板使用 `:coffee`。
（译者注：这一段和上面的图文好像对不上，可能是版本更新过程中忘记删除的旧文。）

信息还包含了 `request.formats`，说明响应使用的模板格式。当我们在浏览器中请求页面时，`request.formats` 被设置为 `text/html`，因此 Rails 会查找 HTML 模板。

在本例中，能够工作的最简单的模板位于 `app/views/articles/new.html.erb` 文件中。文件的扩展名很重要：第一个扩展名是模板格式，第二个扩展名是模板处理器。Rails 会尝试在 `app/views` 文件夹中查找 `articles/new` 模板。这个模板的格式只能是 `html`，模板处理器只能是 `erb`、`builder` 和 `coffee` 中的一个。`:erb` 是最常用的 HTML 模板处理器，`:builder` 是 XML 模板处理器，`:coffee` 模板处理器用 CoffeeScript 创建 JavaScript 模板。因为我们要创建 HTML 表单，所以应该使用能够在 HTML 中嵌入 Ruby 的 `ERB` 语言。

所以我们需要创建 `articles/new.html.erb` 文件，并把它放在程序的 `app/views` 文件夹中。

现在让我们继续前进。新建 `app/views/articles/new.html.erb` 文件，添加下面的代码：

[source,erb]
----
<h1>New Article</h1>
----

刷新 link:$$http://localhost:3000/articles/new$$[]，会看到页面有了标题。现在路由、控制器、动作和视图都可以协调地工作了！是时候创建用于新建文章的表单了。

[[the-first-form]]
==== 第一个表单

在模板中创建表单，可以使用__表单生成器__。Rails 中最常用的表单生成器是 `form_for` 帮助方法。让我们使用这个方法，在 `app/views/articles/new.html.erb` 文件中添加下面的代码：

[source,erb]
----
<%= form_for :article do |f| %>
  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>
<% end %>
----

现在刷新页面，会看到和前文截图一样的表单。在 Rails 中创建表单就是这么简单！

调用 `form_for` 帮助方法时，需要为表单传递一个标识对象作为参数，这里是 `:article` 符号。这个符号告诉 `form_for` 帮助方法表单用于处理哪个对象。在 `form_for` 帮助方法的块中，`f` 表示 `FormBuilder` 对象，用于创建两个标签和两个文本字段，分别用于添加文章的标题和正文。最后在 `f` 对象上调用 `submit` 方法来为表单创建提交按钮。

不过这个表单还有一个问题，查看 HTML 源代码会看到表单 `action` 属性的值是 `/articles/new`，指向的是当前页面，而当前页面只是用于显示新建文章的表单。

应该把表单指向其他 URL，为此可以使用 `form_for` 帮助方法的 `:url` 选项。在 Rails 中习惯用 `create` 动作来处理提交的表单，因此应该把表单指向这个动作。

修改 `app/views/articles/new.html.erb` 文件的 `form_for` 这一行，改为：

[source,erb]
----
<%= form_for :article, url: articles_path do |f| %>
----

这里我们把 `articles_path` 帮助方法传递给 `:url` 选项。要想知道这个方法有什么用，我们可以回过头看一下 `bin/rails routes` 的输出结果：

----
$ bin/rails routes
      Prefix Verb   URI Pattern                  Controller#Action
    articles GET    /articles(.:format)          articles#index
             POST   /articles(.:format)          articles#create
 new_article GET    /articles/new(.:format)      articles#new
edit_article GET    /articles/:id/edit(.:format) articles#edit
     article GET    /articles/:id(.:format)      articles#show
             PATCH  /articles/:id(.:format)      articles#update
             PUT    /articles/:id(.:format)      articles#update
             DELETE /articles/:id(.:format)      articles#destroy
        root GET    /                            welcome#index
----

`articles_path` 帮助方法告诉 Rails 把表单指向和 `articles` 前缀相关联的 URI 模式。默认情况下，表单会向这个路由发起 `POST` 请求。这个路由和当前控制器 `ArticlesController` 的 `create` 动作相关联。

有了表单和与之相关联的路由，我们现在可以填写表单，然后点击提交按钮来新建文章了，请实际操作一下。提交表单后，会看到一个熟悉的错误：

[[unknown-action-new-for-articles]]
.未知动作，在 `ArticlesController` 中找不到 `create` 动作
image::unknown_action_create_for_articles.png[未知动作，在 `ArticlesController` 中找不到 `create` 动作]

解决问题的方法是在 `ArticlesController` 中创建 `create` 动作。

[[creating-articles]]
==== 创建文章

要消除“未知动作”错误，我们需要修改 `app/controllers/articles_controller.rb` 文件，在 `ArticlesController` 类的 `new` 动作之后添加 `create` 动作，就像下面这样：

[source,ruby]
----
class ArticlesController < ApplicationController
  def new
  end

  def create
  end
end
----

现在重新提交表单，会看到什么都没有改变。别着急！这是因为当我们没有说明动作的响应是什么时，Rails 默认返回 `204 No Content response`。我们刚刚添加了 `create` 动作，但没有说明响应是什么。这里，`create` 动作应该把新建文章保存到数据库中。

表单提交后，其字段以__参数__形式传递给 Rails，然后就可以在控制器动作中引用这些参数，以执行特定任务。要想查看这些参数的内容，可以把 `create` 动作的代码修改成下面这样：

[source,ruby]
----
def create
  render plain: params[:article].inspect
end
----

这里 `render` 方法接受了一个简单的 Hash 作为参数，Hash 的 `:plain` 键的值是 `params[:article].inspect`。`params` 方法是代表表单提交的参数（或字段）的对象。`params` 方法返回 `ActionController::Parameters` 对象，这个对象允许使用字符串或符号访问 Hash 的键。这里我们只关注通过表单提交的参数。

TIP: 请确保牢固掌握 `params` 方法，这个方法很常用。让我们看一个示例 URL：link:$$http://www.example.com/?username=dhh&email=dhh@email.com$$[]。在这个 URL 中，`params[:username]` 等于“dhh”，`params[:email]` 等于“dhh@email.com”。

如果再次提交表单，就不会再看到缺少模板错误，而是会看到下面这些内容：

----
<ActionController::Parameters {"title"=>"First Article!", "text"=>"This is my first article."} permitted: false>
----

`create` 动作把表单提交的参数都显示出来了，但这并没有什么用，只是看到了参数实际上却什么也没做。

[[creating-the-article-model]]
==== 创建 Article 模型

在 Rails 中，模型使用单数名称，对应的数据库表使用复数名称。Rails 提供了用于创建模型的生成器，大多数 Rails 开发者在新建模型时倾向于使用这个生成器。要想新建模型，请执行下面的命令：

----
$ bin/rails generate model Article title:string text:text
----

上面的命令告诉 Rails 创建 `Article` 模型，并使模型具有字符串类型的__title__属性和文本类型的__text__属性。这两个属性会自动添加到数据库的 `articles` 表，并映射到 `Article` 模型。

为此 Rails 会创建一堆文件。这里我们只关注 `app/models/article.rb` 和 `db/migrate/20140120191729_create_articles.rb` 这两个文件 （后面这个文件名和你看到的可能会有点不一样）。后面这个文件负责创建数据库结构，下一节会详细说明。

TIP: Active Record 很智能，能自动把数据表的字段名映射到模型属性上，因此无需在 Rails 模型中声明属性，让 Active Record 自动完成即可。

[[running-a-migration]]
==== 运行移移

如前文所述，`bin/rails generate model` 命令会在 `db/migrate` 文件夹中生成__数据库迁移__文件。迁移是用于简化创建和修改数据库表操作的 Ruby 类。Rails 使用 rake 命令运行迁移，并且在迁移作用于数据库之后还可以撤销迁移操作。迁移的文件名包含了时间戳，以确保迁移按照创建时间顺序运行。

让我们看一下 `db/migrate/YYYYMMDDHHMMSS_create_articles.rb` 文件（记住，你的文件名可能会有点不一样），会看到下面的内容：

[source,ruby]
----
class CreateArticles < ActiveRecord::Migration[5.0]
  def change
    create_table :articles do |t|
      t.string :title
      t.text :text

      t.timestamps
    end
  end
end
----

上面的迁移创建了 `change` 方法，在运行迁移时会调用这个方法。在 `change` 方法中定义的操作都是可逆的，在需要时 Rails 知道如何撤销这些操作。运行迁移后会创建 `articles` 表，这个表包括一个字符串字段和一个文本字段，以及两个用于跟踪文章创建和更新时间的时间戳字段。

TIP: 关于迁移的更多介绍，请参阅 link:$$http://guides.rubyonrails.org/migrations.html$$[Rails 数据库迁移] 一文。

现在可以使用 `bin/rails` 命令运行迁移了：

----
$ bin/rails db:migrate
----

Rails 会执行迁移命令并告诉我们它创建了 Articles 表.

----
==  CreateArticles: migrating ==================================================
-- create_table(:articles)
   -> 0.0019s
==  CreateArticles: migrated (0.0020s) =========================================
----

NOTE: 因为默认情况下我们是在开发环境中工作，所以上述命令应用于 `config/database.yml` 文件中 `development` 部分定义的的数据库。要想在其他环境中执行迁移，例如生产环境，就必须在调用命令时显式传递环境变量：`bin/rails db:migrate RAILS_ENV=production`。

[[saving-data-in-the-controller]]
==== 在控制器中保存数据

回到 `ArticlesController`，修改 `create` 动作，使用新建的 `Article` 模型把数据保存到数据库。打开 `app/controllers/articles_controller.rb` 文件，像下面这样修改 `create` 动作：

[source,ruby]
----
def create
  @article = Article.new(params[:article])

  @article.save
  redirect_to @article
end
----

让我们看一下上面的代码都做了什么：Rails 模型可以用相应的属性初始化，它们会自动映射到对应的数据库字段。`create` 动作中的第一行代码完成的就是这个操作（记住，`params[:article]` 包含了我们想要的属性）。接下来 `@article.save` 负责把模型保存到数据库。最后把页面跳转到 `show` 动作，这个 `show` 动作我们稍后再定义。

TIP: 你可能想知道，为什么在上面的代码中 `Article.new` 的 `A` 是大写的，而在本文的其他地方引用 articles 时大都是小写的。因为这里我们引用的是在 `app/models/article.rb` 文件中定义的 `Article` 类，而在 Ruby 中类名必须以大写字母开头。

TIP: 之后我们会看到，`@article.save` 返回布尔值，以表明文章是否保存成功。

现在访问 link:$$http://localhost:3000/articles/new$$[]，我们__就快要__能够创建文章了，但我们还会看到下面的错误：

[[forbidden-attributes-for-new-article]]
.禁用属性错误
image::forbidden_attributes_for_new_article.png[禁用属性错误]

Rails 提供了多种安全特性来帮助我们编写安全的程序，上面看到的就是一种安全特性。这个安全特性叫做健壮参数（请参阅 <<action_controller_overview#strong-parameters>>），要求我们明确地告诉 Rails 哪些参数允许在控制器动作中使用。

为什么我们要这样自找麻烦呢？一次性获取所有控制器参数并自动赋值给模型显然更简单，但这样做会造成恶意使用的风险。设想一下，如果有人对服务器发起了一个精心设计的请求，看起来就像提交了一篇新文章，但同时包含了能够破坏程序完整性的额外字段和值，会怎么样？这些恶意数据会多重赋值给模型，然后和正常数据一起进入数据库，这样就有可能破坏我们的程序或者造成更大损失。

所以我们只能为控制器参数设置白名单，以避免错误地多重赋值。这里，我们想在 `create` 动作中合法使用 `title` 和 `text` 参数，为此需要使用 `require` 和 `permit` 语法。像下面这样修改 `create` 动作中的一行代码：

[source,ruby]
----
@article = Article.new(params.require(:article).permit(:title, :text))
----

上述代码通常被抽象为控制器类的一个方法，以便在控制器的多个动作中重用，例如在 `create` 和 `update` 动作中都会用到这个方法。除了多重赋值问题，为了禁止从外部调用这个方法，通常还要把它设置为 `private`。最后的代码像下面这样：

[source,ruby]
----
def create
  @article = Article.new(article_params)

  @article.save
  redirect_to @article
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end
----

TIP: 关于键壮参数的更多介绍，请参阅 <<action_controller_overview#strong-parameters>> 和 link:$$http://weblog.rubyonrails.org/2012/3/21/strong-parameters/$$[这篇博客]。

[[showing-articles]]
==== 显示文章

现在再次提交表单，Rails 会提示找不到 `show` 动作。尽管这个提示没有多大用处，但在继续前进之前我们还是先添加 `show` 动作吧。

之前我们在 `bin/rails routes` 命令的输出结果中看到，`show` 动作对应的路由是：

----
article GET    /articles/:id(.:format)      articles#show
----

特殊语法 `:id` 告诉 Rails 这个路由期望接受 `:id` 参数，在这里也就是文章的 ID。

和前面一样，我们需要在 `app/controllers/articles_controller.rb` 文件中添加 `show` 动作，并创建对应的视图文件。

NOTE: 常见的做法是按照以下顺序在控制器中放置标准的 CRUD 动作：`index`，`show`，`new`，`edit`，`create`，`update` 和 `destroy`。你也可以按照自己的顺序放置这些动作，但要记住它们都是公共方法，如前文所述，必须放在控制器的私有方法或受保护的方法之前才能正常工作。

有鉴于此，让我们像下面这样添加 `show` 动作：

[source,ruby]
----
class ArticlesController < ApplicationController
  def show
    @article = Article.find(params[:id])
  end

  def new
  end

  # snippet for brevity
----

上面的代码中有几个问题需要注意。我们使用 `Article.find` 来查找文章，并传入 `params[:id]` 以便从请求中获得 `:id` 参数。我们还使用实例变量（前缀为 `@`）保存对文章对象的引用。这样做是因为 Rails 会把所有实例变量传递给视图。

现在新建 `app/views/articles/show.html.erb` 文件，添加下面的代码：

[source,erb]
----
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>
----

通过上面的修改，我们终于能够新建文章了。访问 link:$$http://localhost:3000/articles/new$$[]，自己试一试吧！

[[show-action-for-articles]]
.显示文章
image::show_action_for_articles.png[显示文章]

[[listing-all-articles]]
==== 列出所有文章

我们还需要列出所有文章，下面就来完成这个功能。在 `bin/rails routes` 命令的输出结果中，和列出文章对应的路由是：

----
articles GET    /articles(.:format)          articles#index
----

在 `app/controllers/articles_controller.rb` 文件的 `ArticlesController` 中为上述路由添加对应的 `index` 动作。在编写 `index` 动作时，常见的做法是把它作为控制器的第一个方法，就像下面这样：

[source,ruby]
----
class ArticlesController < ApplicationController
  def index
    @articles = Article.all
  end

  def show
    @article = Article.find(params[:id])
  end

  def new
  end

  # snippet for brevity
----

最后，在 `app/views/articles/index.html.erb` 文件中为 `index` 动作添加视图：

[source,erb]
----
<h1>Listing articles</h1>

<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
  </tr>

  <% @articles.each do |article| %>
    <tr>
      <td><%= article.title %></td>
      <td><%= article.text %></td>
      <td><%= link_to 'Show', article_path(article) %></td>
    </tr>
  <% end %>
</table>
----

现在访问 link:$$http://localhost:3000/articles$$[]，会看到已创建的所有文章的列表。

[[adding-links]]
==== 添加链接

至此，我们可以创建、显示、列出文章了。下面我们添加一些指向这些页面的链接。

打开 `app/views/welcome/index.html.erb` 文件，修改成下面这样：

[source,erb]
----
<h1>Hello, Rails!</h1>
<%= link_to 'My Blog', controller: 'articles' %>
----

`link_to` 方法是 Rails 内置的视图帮助方法之一，用于创建基于链接文本和地址的超链接。在这里地址指的是文章列表页面的路径。

接下来添加指向其他视图的链接。首先在 `app/views/articles/index.html.erb` 文件中添加“New Article”链接，把这个链接放在 `<table>` 标签之前：

[source,erb]
----
<%= link_to 'New article', new_article_path %>
----

点击这个链接会打开用于新建文章的表单。

接下来在 `app/views/articles/new.html.erb` 文件中添加返回 `index` 动作的链接，把这个链接放在表单之后：

[source,erb]
----
<%= form_for :article, url: articles_path do |f| %>
  ...
<% end %>

<%= link_to 'Back', articles_path %>
----

最后，在 `app/views/articles/show.html.erb` 模板中添加返回 `index` 动作的链接，这样用户看完一篇文章后就可以返回文章列表页面了：

[source,erb]
----
<p>
  <strong>Title:</strong>
  <%= @article.title %>
</p>

<p>
  <strong>Text:</strong>
  <%= @article.text %>
</p>

<%= link_to 'Back', articles_path %>
----

TIP: 要想链接到当前控制器中的动作，不需要指定 `:controller` 选项，因为 Rails 默认使用当前控制器。

TIP: 在开发环境中（默认情况下我们是在开发环境中工作），Rails 针对每个浏览器请求都会重新加载程序，因此对程序进行修改后不需要重启服务器。

[[adding-some-validation]]
==== 添加验证

`app/models/article.rb` 模型文件简单到只有两行代码：

[source,rub]
----
class Article < ApplicationRecord
end
----

虽然这个文件中代码很少，但请注意 `Article` 类继承至 `ApplicationRecord` 类，而 `ApplicationRecord` 类继承至 `ActiveRecord::Base` 类。正是 `ActiveRecord::Base` 类为 Rails 模型提供了大量功能，包括基本的数据库 CRUD 操作（创建、读取、更新、删除）、数据验证，以及对复杂搜索的支持和关联多个模型的能力。

Rails 提供了许多方法用于验证传入模型的数据。打开 `app/models/article.rb` 文件，像下面这样修改：

[source,ruby]
----
class Article < ApplicationRecord
  validates :title, presence: true,
                    length: { minimum: 5 }
end
----

添加的代码用于确保每篇文章都有标题，并且标题长度不少于 5 个字符。在 Rails 模型中可以验证多种条件，包括字段是否存在、字段是否唯一、字段的格式、关联对象是否存在等。关于验证的更多介绍，请参阅“Active Record 验证”（<<active_record_validations>>）。

现在验证已经添加完毕，如果我们在调用 `@article.save` 时传递了无效的文章数据，验证就会返回 `false`。再次打开 `app/controllers/articles_controller.rb` 文件，会看到我们并没有在 `create` 动作中检查 `@article.save` 的调用结果。在这里如果 `@article.save` 失败了，就需要把表单再次显示给用户。为此需要像下面这样修改 `app/controllers/articles_controller.rb` 文件中的 `new` 和 `create` 动作：

[source,ruby]
----
def new
  @article = Article.new
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end
----

在上面的代码中，我们在 `new` 动作中创建了新的实例变量 `@article`，稍后你就会知道为什么要这样做。

注意在 `create` 动作中，当 `save` 返回 `false` 时，我们用 `render` 代替了 `redirect_to`。使用 `render` 方法是为了把 `@article` 对象回传给 `new` 模板。这里渲染操作是在提交表单的这个请求中完成的，而 `redirect_to` 会告诉浏览器发起另一个请求。

刷新 link:$$http://localhost:3000/articles/new$$[]，试着提交一篇没有标题的文章，Rails 会返回这个表单，但这种处理方式没有多大用处，更好的做法是告诉用户哪里出错了。为此需要修改 `app/views/articles/new.html.erb` 文件，添加检查出错信息的代码：

[source,erb]
----
<%= form_for :article, url: articles_path do |f| %>

  <% if @article.errors.any? %>
    <div id="error_explanation">
      <h2>
        <%= pluralize(@article.errors.count, "error") %> prohibited
        this article from being saved:
      </h2>
      <ul>
        <% @article.errors.full_messages.each do |msg| %>
          <li><%= msg %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>

<% end %>

<%= link_to 'Back', articles_path %>
----

上面我们添加了一些代码。我们使用 `@article.errors.any?` 检查是否有错误，如果有错误就使用 `@article.errors.full_messages` 显示所有出错信息的列表。

`pluralize` 是 Rails 提供的帮助方法，接受一个数字和一个字符串作为参数。如果这个数字比 1 大，这个字符串就会被自动转换为复数形式。

在 `ArticlesController` 中添加 `@article = Article.new` 是因为如果不这样做，在视图中 `@article` 的值就会是 `nil`，这样在调用 `@article.errors.any?`时就会抛出错误。

TIP: Rails 会自动用 div 包装含有出错信息的字段，并为这些 div 添加 `field_with_errors` 类。我们可以定义 CSS 规则来突出显示这些出错信息。

当我们再次访问 link:$$http://localhost:3000/articles/new$$[]，试着提交一篇没有标题的文章，就会看到友好的出错信息。

[[form-with-errors]]
.出错的表单
image::form_with_errors.png[出错的表单]

[[updating-articles]]
==== 更新文章

我们已经介绍了 CRUD 操作中的“CR”两种操作，下面让我们看一下“U”操作，也就是更新文章。

第一步要在  ArticlesController 中添加 `edit` 动作，通常把这个动作放在 `new` 动作和 `create` 动作之间，就像下面这样：

[source,ruby]
----
def new
  @article = Article.new
end

def edit
  @article = Article.find(params[:id])
end

def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end
----

接下来在视图中添加一个表单，这个表单类似于前文用于新建文章的表单。创建 `app/views/articles/edit.html.erb` 文件，添加下面的代码：

[source,erb]
----
<h1>Editing article</h1>

<%= form_for :article, url: article_path(@article), method: :patch do |f| %>

  <% if @article.errors.any? %>
    <div id="error_explanation">
      <h2>
        <%= pluralize(@article.errors.count, "error") %> prohibited
        this article from being saved:
      </h2>
      <ul>
        <% @article.errors.full_messages.each do |msg| %>
          <li><%= msg %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>

<% end %>

<%= link_to 'Back', articles_path %>
----

上面的代码把表单指向了 `update` 动作，这个动作稍后我们再来定义。

`method: :patch` 选项告诉 Rails 使用 `PATCH` 方法提交表单。根据 REST 协议，`PATCH` 方法是**更新**资源时使用的 HTTP 方法。

`form_for` 帮助方法的第一个参数可以是对象，例如 `@article`，`form_for` 帮助方法会用这个对象的字段来填充表单。如果传入和实例变量（`@article`）同名的符号（`:article`），也会自动产生相同效果，上面的代码使用的就是符号。关于 `form_for` 帮助方法参数的更多介绍，请参阅 link:$$http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_for$$[form_for 文档]。

接下来在 `app/controllers/articles_controller.rb` 文件中创建 `update` 动作，把这个动作放在 `create` 动作和 `private` 方法之间：

[source,ruby]
----
def create
  @article = Article.new(article_params)

  if @article.save
    redirect_to @article
  else
    render 'new'
  end
end

def update
  @article = Article.find(params[:id])

  if @article.update(article_params)
    redirect_to @article
  else
    render 'edit'
  end
end

private
  def article_params
    params.require(:article).permit(:title, :text)
  end
----

`update` 动作用于更新已有记录，它接受 Hash 作为参数，Hash 中包含想要更新的属性。和之前一样，如果更新文章时发生错误，就需要把表单再次显示给用户。

上面的代码重用了之前为 `create` 动作定义的 `article_params` 方法。

TIP: 不用把所有属性都传递给 `update` 方法。例如，调用 `@article.update(title: 'A new title')` 时，Rails 只更新 `title` 属性而不修改其他属性。

最后，我们想在文章列表中显示指向 `edit` 动作的链接。打开 `app/views/articles/index.html.erb` 文件，在 `Show` 链接后面添加 `Edit` 链接：

[source,erb]
----
<table>
  <tr>
    <th>Title</th>
    <th>Text</th>
    <th colspan="2"></th>
  </tr>

  <% @articles.each do |article| %>
    <tr>
      <td><%= article.title %></td>
      <td><%= article.text %></td>
      <td><%= link_to 'Show', article_path(article) %></td>
      <td><%= link_to 'Edit', edit_article_path(article) %></td>
    </tr>
  <% end %>
</table>
----

接着在 `app/views/articles/show.html.erb` 模板中添加 `Edit` 链接，这样文章页面也有 `Edit` 链接了。把这个链接添加到模板底部：

[source,erb]
----
...

<%= link_to 'Edit', edit_article_path(@article) %> |
<%= link_to 'Back', articles_path %>
----

下面是文章列表现在的样子：

[[listing-articles]]
.列出文章
image::index_action_with_edit_link.png[列出文章]


[[using-partials-to-clean-up-duplication-in-views]]
==== 使用局部视图去掉视图中的重复代码

编辑文章页面和新建文章页面看起来很相似，实际上这两个页面用于显示表单的代码是相同的。现在我们要用局部视图来去掉这些重复代码。按照约定，局部视图的文件名以下划线开头。

TIP: 关于局部视图的更多介绍，请参阅“Rails中的布局和渲染”（<<layouts_and_rendering>>）一文。

新建 `app/views/articles/_form.html.erb` 文件，添加下面的代码：

[source,erb]
----
<%= form_for @article do |f| %>

  <% if @article.errors.any? %>
    <div id="error_explanation">
      <h2>
        <%= pluralize(@article.errors.count, "error") %> prohibited
        this article from being saved:
      </h2>
      <ul>
        <% @article.errors.full_messages.each do |msg| %>
          <li><%= msg %></li>
        <% end %>
      </ul>
    </div>
  <% end %>

  <p>
    <%= f.label :title %><br>
    <%= f.text_field :title %>
  </p>

  <p>
    <%= f.label :text %><br>
    <%= f.text_area :text %>
  </p>

  <p>
    <%= f.submit %>
  </p>

<% end %>
----

除了第一行 `form_for` 的用法变了之外，其他代码都和之前一样。之所以能用这个更短、更简单的 `form_for` 声明来代替新建文章页面和编辑文章页面的两个表单，是因为 `@article` 是一个资源，对应于一套 REST 架构的路由，Rails 能够推断出应该使用哪个地址和方法。关于 `form_for` 用法的更多介绍，请参阅 link:$$http://api.rubyonrails.org/classes/ActionView/Helpers/FormHelper.html#method-i-form_for-label-Resource-oriented+style$$[面向资源的风格]。

现在更新 `app/views/articles/new.html.erb` 视图，以使用新建的局部视图。把文件内容替换为下面的代码：

[source,erb]
----
<h1>New article</h1>

<%= render 'form' %>

<%= link_to 'Back', articles_path %>
----

然后按照同样的方法修改 `app/views/articles/edit.html.erb` 视图：

[source,erb]
----
<h1>Edit article</h1>

<%= render 'form' %>

<%= link_to 'Back', articles_path %>
----

[[deleting-articles]]
==== 删除文章
