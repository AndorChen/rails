[[ruby-on-rails-security-guide]]
== Ruby on Rails 安全指南
:imagesdir: ../images
:numbered:

// chinakr 翻译

[.chapter-abstract]
--
本文介绍 Web 应用中常见的安全问题，以及如何在 Rails 中避免这些问题。

读完本文后，您将学到：

* 所有需要强调的安全对策；
* Rails 中会话的概念，应该在会话中保存什么内容，以及常见的攻击方式；
* 为什么访问网站也可能带来安全问题（跨站请求伪造）；
* 处理文件或提供管理界面时需要注意的问题；
* 如何管理用户：登录、退出，以及不同层次上的攻击方式；
* 最常见的注入攻击方式。
--

[[introduction]]
=== 简介

Web 应用框架的作用是帮助开发者创建 Web 应用。其中一些框架还能帮助我们提高 Web 应用的安全性。事实上，框架之间无所谓谁更安全，对于许多框架来说，只要使用正确，我们都能开发出安全的应用。Ruby on Rails 提供了一些十分智能的辅助方法，例如，用于防止 SQL 注入的辅助方法，极大减少了这一安全风险。

一般来说，并不存在什么即插即用的安全机制。安全性取决于开发者如何使用框架，有时也取决于开发方式。安全性还取决于 Web 应用环境的各个层面，包括后端存储、Web 服务器和 Web 应用自身等（甚至包括其他 Web应用）。

不过，据高德纳咨询公司（Gartner Group）估计，75% 的攻击发生在 Web 应用层面，报告称“在进行了安全审计的 300 个网站中，97% 存在被攻击的风险”。这是因为针对 Web 应用的攻击相对来说更容易实施，其工作原理和具体操作都比较简单，即使是非专业人士也能发起攻击。

针对 Web 应用的安全威胁包括账户劫持、绕过访问控制、读取或修改敏感数据，以及显示欺诈信息等。有时，攻击者还会安装木马程序或使用垃圾邮件群发软件，以便获取经济利益，或者通过篡改公司资源来损害品牌形象。为了防止这些攻击，最大限度降低或消除攻击造成的影响，首先我们必须全面了解各种攻击方式，只有这样才能找出正确对策——这正是本文的主要目的。

为了开发安全的 Web 应用，我们必须从各个层面紧跟安全形势，做到知己知彼。为此，我们可以订阅安全相关的邮件列表，阅读相关博客，同时养成及时更新并定期进行安全检查的习惯（请参阅 <<http://guides.rubyonrails.org/security.html#additional-resources,其他资源>> 一节）。这些工作都是手动完成的，只有这样我们才能发现潜在安全隐患。

[[sessions]]
=== 会话

从会话入手来了解安全问题是一个很好的切入点，因为会话对于特定攻击十分脆弱。

[[what-are-sessions]]
==== 会话是什么

NOTE: HTTP 是无状态协议，会话使其有状态。

大多数应用需要跟踪特定用户的某些状态，例如购物车里的商品、当前登录用户的 ID 等。如果没有会话，就需要为每一次请求标识用户甚至进行身份验证。当新用户访问应用时，Rails 会自动新建会话，如果用户曾经访问过应用，就会加载已有会话。

会话通常由值的散列和会话 ID（通常为 32 个字符的字符串）组成，其中会话 ID 用于标识散列。发送到客户端浏览器的每个 Cookie 都包含会话 ID，另一方面，客户端浏览器发送到服务器的每个请求也包含会话 ID。在 Rails 中，我们可以使用 `session` 方法保存和取回值：

[source,ruby]
----
session[:user_id] = @current_user.id
User.find(session[:user_id])
----

[[session-id]]
==== 会话 ID

NOTE: 会话 ID 是长度为 32 字节的 MD5 散列值。

会话 ID 由随机字符串的散列值组成。这个随机字符串包含当前时间，一个 0 到 1 之间的随机数，Ruby 解析器的进程 ID（基本上也是一个随机数），以及一个常量字符串。目前 Rails 会话 ID 还无法暴力破解。尽管直接破解 MD5 很难，但存在 MD5 碰撞的可能性，理论上可以创建具有相同散列值的另一个输入文本。不过到目前为止，这个问题还未产生安全影响。

[[session-hijacking]]
==== 会话劫持

WARNING: 通过窃取用户的会话 ID，攻击者能够以受害者的身份使用 Web 应用。

很多 Web 应用都有身份验证系统：用户提供用户名和密码，Web 应用在验证后把对应的用户 ID 储存到会话散列中。之后，会话就可以合法使用了。对于每个请求，应用都会通过识别会话中储存的用户 ID 来加载用户，从而避免了重新进行身份验证。Cookie 中的会话 ID 用于标识会话。

因此，Cookie 提供了 Web 应用的临时身份验证。只要得到了他人的 Cookie，任何人都能以该用户的身份使用 Web 应用，这可能导致严重的后果。下面介绍几种劫持会话的方式及其对策：

* 在不安全的网络中嗅探 Cookie。无线局域网就是一个例子。在未加密的无线局域网中，监听所有已连接客户端的流量极其容易。因此，Web 应用开发者应该通过 SSL 提供安全连接。在 Rails 3.1 和更高版本中，可以在应用配置文件中设置强制使用 SSL 连接：

[source,ruby]
----
config.force_ssl = true
----

* 大多数人在使用公共终端后不会清除 Cookie。因此，如果最后一个用户没有退出 Web 应用，后续用户就能以该用户的身份继续使用。因此，Web 应用一定要提供“退出”按钮，并且要尽可能显眼。

* 很多跨站脚本（XSS）攻击的目标是获取用户 Cookie。更多介绍请参阅 <<http://guides.rubyonrails.org/security.html#cross-site-scripting-xss,跨站脚本攻击>> 一节。

* 有的攻击者不窃取 Cookie，而是篡改用户 Cookie 中的会话 ID。这种攻击方式被称为固定会话攻击，后文会详细介绍。

大多数攻击者的主要目标是赚钱。根据赛门铁克《互联网安全威胁报告》，被窃取的银行登录账户的黑市价格从 10 到 1000 美元不等（取决于账户余额），信用卡卡号为 0.40 到 20 美元，在线拍卖网站的账户为 1 到 8 美元，电子邮件账户密码为 4 到 30 美元。

[[session-guidelines]]
==== 会话安全指南

下面是一些关于会话安全的一般性指南。

* 不要在会话中储存大型对象，而应该把它们储存在数据库中，并将其 ID 保存在会话中。这么做可以避免同步问题，并且不会导致会话存储空间耗尽（会话存储空间的大小取决于其类型，详见后文）。如果不这么做，当修改了对象结构时，用户 Cookie 中保存的仍然是对象的旧版本。通过在服务器端储存会话，我们可以轻而易举地清除会话，而在客户端储存会话，要想清除会话就很麻烦了。

* 关键数据不应该储存在会话中。如果用户清除了 Cookie 或关闭了浏览器，这些关键数据就会丢失。并且在客户端储存会话，还会导致用户能够读取关键数据。

[[session-storage]]
==== 会话存储

NOTE: Rails 提供了几种会话散列的存储机制。其中最重要的是 `ActionDispatch::Session::CookieStore`。

Rails 2 引入了一种新的默认会话存储机制——CookieStore。CookieStore 把会话散列直接储存在客户端的 Cookie 中。无需会话 ID，服务器就可以从 Cookie 中取回会话散列。这么做可以显著提高程序的运行速度，但也存在争议，因为这种存储机制具有下列安全隐患：

* Cookie 的大小被严格限制为 4 KB。这个限制本身没问题，因为如前文所述，本来就不应该在会话中储存大量数据。在会话中储存当前用户的数据库 ID 一般没问题。

* 客户端可以看到储存在会话中的所有内容，因为数据是以明文形式储存的（实际上是 Base64 编码，因此没有加密）。因此，我们不应该在会话中储存隐私数据。为了防止会话散列被篡改，应该根据服务器端密令（`secrets.secret_token`）计算会话的摘要（digest），然后把这个摘要添加到 Cookie 的末尾。

不过，从 Rails 4 开始，默认存储机制是 EncryptedCookieStore。EncryptedCookieStore 会先对会话进行加密，再储存到 Cookie 中。这么做可以防止用户访问和篡改 Cookie 的内容。因此，会话也成为储存数据的更安全的地方。加密时需要使用 `config/secrets.yml` 文件中储存的服务器端密钥 `secrets.secret_key_base`。

这意味着 EncryptedCookieStore 存储机制的安全性由密钥（以及摘要算法，出于兼容性考虑默认为 SHA1 算法）决定。因此，密钥不能随意取值，例如从字典中找一个单词，或少于 30 个字符，应该使用 `rails secret` 生成密钥。

`secrets.secret_key_base` 用于指定密钥，在应用中会话使用这个密钥来验证已知密钥，以防止篡改。在创建应用时，`config/secrets.yml` 文件中储存的 `secrets.secret_key_base` 是一个随机密钥，例如：

[source,yml]
----
development:
  secret_key_base: a75d...

test:
  secret_key_base: 492f...

production:
  secret_key_base: <%= ENV["SECRET_KEY_BASE"] %>
----

Rails 老版本中的 CookieStore 使用的是 `secret_token`，而不是 EncryptedCookieStore 所使用的 `secret_key_base`。更多介绍请参阅升级文档。

如果应用的密钥泄露了（例如应用开放了源代码），强烈建议更换密钥。

[[replay-attacks-for-cookiestore-sessions]]
==== 对 CookieStore 会话的重放攻击（replay attack）

NOTE: 重放攻击是使用 CookieStore 时必须注意的另一种攻击方式。

重放攻击的工作原理如下：

* 用户获得的信用额度保存在会话中（信用额度实际上不应该保存在会话中，这里只是出于演示目的才这样做）；
* 用户使用部分信用额度购买商品；
* 减少后的信用额度仍然保存在会话中；
* 用户先前复制了第一步中的 Cookie，并用这个 Cookie 替换浏览器中的当前 Cookie；
* 用户重新获得了消费前的信用额度。

在会话中包含随机数可以防止重放攻击。每个随机数验证一次后就会失效，服务器必须跟踪所有有效的随机数。当有多个应用服务器时，情况会变得更复杂，因为我们不能把随机数储存在数据库中，否则就违背了使用 CookieStore 的初衷（避免访问数据库）。

因此，防止重放攻击的最佳方案，不是把这类敏感数据储存在会话中，而是把它们储存在数据库中。回到上面的例子，我们可以把信用额度储存在数据库中，而把当前用户的 ID 储存在会话中。

[[session-fixation]]
==== 会话固定攻击（session fixation）

NOTE: 除了窃取用户的会话 ID 之外，攻击者还可以直接使用已知的会话 ID。这种攻击方式被称为会话固定攻击。

image::session_fixation.png[]

会话固定攻击的关键是强制用户的浏览器使用攻击者已知的会话 ID，这样攻击者就无需窃取会话 ID。会话固定攻击的工作原理如下：

* 攻击者创建一个合法的会话 ID：打开 Web 应用的登录页面，从响应中获取 Cookie 中的会话 ID（参见上图中的第 1 和第 2 步）。
* 攻击者定期访问 Web 应用，以避免会话过期。
* 攻击者强制用户的浏览器使用这个会话 ID（参见上图中的第 3 步）。由于无法修改另一个域名的 Cookie（基于同源原则的限制），攻击者必须在目标 Web 应用的域名上运行 JavaScript 代码，也就是通过 XSS 把 JavaScript 代码注入目标 Web 应用来完成攻击。例如：`<script>document.cookie="_session_id=16d5b78abb28e3d6206b60f22a03c8d9";</script>`。关于 XSS 和注入的更多介绍见后文。
* 攻击者诱使用户访问包含恶意 JavaScript 代码的页面，这样用户的浏览器中的会话 ID 就会被篡改为攻击者已知的会话 ID。
* 由于这个被篡改的会话还未使用过，Web 应用会进行身份验证。
* 此后，用户和攻击者将共用同一个会话来访问 Web 应用。攻击者篡改后的会话成为了合法会话，用户面对攻击却浑然不知。

[[session-fixation-countermeasures]]
==== 会话固定攻击的对策

TIP: 一行代码就能保护我们免受会话固定攻击。

面对会话固定攻击，最有效的对策是在登录成功后重新设置会话 ID，并使原有会话 ID 失效，这样攻击者持有的会话 ID 也就失效了。这也是防止会话劫持的有效对策。在 Rails 中重新设置会话 ID 的方式如下：

[source,ruby]
----
reset_session
----

如果我们使用流行的 link:$$https://rubygems.org/gems/devise[Devise] gem 完成用户管理，Devise 会在用户登录和退出时自动使原有会话过期。如果打算手动完成用户管理，请记住在登录操作后（新会话创建后）使原有会话过期。会话过期后其中的值都会被删除，因此我们需要把有用的值转移到新会话中。

另一个对策是在会话中保存用户相关的属性，对于每次请求都验证这些属性，如果信息不匹配就拒绝访问。这些属性包括 IP 地址、用户代理（Web 浏览器名称），其中用户代理的用户相关性要弱一些。在保存 IP 地址时，必须注意，有些网络服务提供商（ISP）或大型组织，会把用户置于代理服务器之后。在会话的生命周期中，这些代理服务器有可能发生变化，从而导致用户无法正常使用应用，或出现权限问题。

[[session-expiry]]
==== 会话过期

NOTE: 永不过期的会话增加了跨站请求伪造（CSRF）、会话劫持和会话固定攻击的风险。

Cookie 的过期时间可以通过会话 ID 设置。然而，客户端能够修改储存在 Web 浏览器中的 Cookie，因此在服务器上使会话过期更安全。下面的例子演示了如何使储存在数据库中的会话过期。通过调用 `Session.sweep("20 minutes")`，可以使闲置超过 20 分钟的会话过期。

[source,ruby]
----
class Session < ApplicationRecord
  def self.sweep(time = 1.hour)
    if time.is_a?(String)
      time = time.split.inject { |count, unit| count.to_i.send(unit) }
    end

    delete_all "updated_at < '#{time.ago.to_s(:db)}'"
  end
end
----

“会话固定攻击”一节介绍了维护会话的问题。攻击者每五分钟维护一次会话，就可以使会话永远保持活动，不会过期。针对这个问题的一个简单解决方案是在会话数据表中添加 `created_at` 字段，这样就可以找出创建了很长时间的会话并删除它们。可以用下面这行代码代替上面例子中的对应代码：

[source,ruby]
----
delete_all "updated_at < '#{time.ago.to_s(:db)}' OR
  created_at < '#{2.days.ago.to_s(:db)}'"
----

[[cross-site-request-forgery-csrf]]
=== 跨站请求伪造（CSRF）
