[[the-rails-initialization-process]]
== Rails 初始化过程
:imagesdir: ../images
:numbered:

// chinakr 翻译

[.chapter-abstract]
--
本文介绍 Rails 初始化过程的内部细节，内容较深，建议 Rails 高级开发者阅读。

读完本文后，您将学到：

* 如何使用 `rails server`；
* Rails 初始化过程的时间表；
* 引导过程中所需的不同文件的所在位置；
* `Rails::Server` 接口的定义和使用方式。
--

本文介绍默认情况下，Rails 应用初始化过程中的每一个方法调用，详细解释各个步骤的具体细节。本文将聚焦于使用 `rails server` 启动 Rails 应用时发生的事情。

NOTE: 除非另有说明，本文中出现的路径都是相对于 Rails 或 Rails 应用所在目录的相对路径。

TIP: 如果想一边阅读本文一边查看 link:$$https://github.com/rails/rails$$[Rails 源代码]，推荐在 GitHub 中使用 `t` 快捷键打开文件查找器，以便快速查找相关文件。

[[launch]]
=== 启动

首先介绍 Rails 应用引导和初始化的过程。我们可以通过 `rails console` 或 `rails server` 命令启动 Rails 应用。

[[railties-exe-rails]]
==== `railties/exe/rails` 文件

`rails server` 命令中的 `rails` 是位于加载路径中的 Ruby 可执行文件。这个文件包含如下内容：

[source,ruby]
----
version = ">= 0"
load Gem.bin_path('railties', 'rails', version)
----

在 Rails 控制台中运行上述代码，可以看到加载的是 `railties/exe/rails` 文件（译者注：在 Rails 5.0.1 中看到的是 `rails` 命令的使用帮助）。`railties/exe/rails` 文件的部分内容如下：

[source,ruby]
----
require "rails/cli"
----

`railties/lib/rails/cli` 文件又会调用 `Rails::AppLoader.exec_app` 方法。

[[railties-lib-rails-app-loader-rb]]
==== `railties/lib/rails/app_loader.rb` 文件

`exec_app` 方法的主要作用是执行应用中的 `bin/rails` 文件。如果在当前文件夹中未找到 `bin/rails` 文件，就会继续在上层文件夹中查找，直到找到为止。因此，我们可以在 Rails 应用中的任何位置执行 `rails` 命令。

执行 `rails server` 命令时，实际执行的是等价的下述命令：

[source,sh]
----
$ exec ruby bin/rails server
----

[[bin-rails]]
==== `bin/rails` 文件

此文件包含如下内容：

[source,ruby]
----
#!/usr/bin/env ruby
APP_PATH = File.expand_path('../../config/application', __FILE__)
require_relative '../config/boot'
require 'rails/commands'
----

其中 `APP_PATH` 常量稍后将在 `rails/commands` 中使用。所加载的 `config/boot` 是应用中的 `config/boot.rb` 文件，用于加载并设置 Bundler。

[[config-boot-rb]]
==== `config/boot.rb` 文件

此文件包含如下内容：

[source,ruby]
----
ENV['BUNDLE_GEMFILE'] ||= File.expand_path('../../Gemfile', __FILE__)

require 'bundler/setup' # 设置 Gemfile 中列出的所有 gem
----

标准的 Rails 应用中包含 `Gemfile` 文件，用于声明应用的所有依赖关系。`config/boot.rb` 文件会把 `ENV['BUNDLE_GEMFILE']` 设置为 `Gemfile` 文件的路径。如果 `Gemfile` 文件存在，就会加载 `bundler/setup`，Bundler 通过它设置 Gemfile 中依赖关系的加载路径。

标准的 Rails 应用依赖多个 gem，包括：

* actionmailer
* actionpack
* actionview
* activemodel
* activerecord
* activesupport
* activejob
* arel
* builder
* bundler
* erubis
* i18n
* mail
* mime-types
* rack
* rack-cache
* rack-mount
* rack-test
* rails
* railties
* rake
* sqlite3
* thor
* tzinfo

[[rails-commands-rb]]
==== `rails/commands.rb` 文件

执行完 `config/boot.rb` 文件，下一步就要加载 `rails/commands`，其作用是扩展命令别名。在本例中（输入的命令为 `rails server`），`ARGV` 数组只包含将要传递的 `server` 命令：

[source,ruby]
----
ARGV << '--help' if ARGV.empty?

aliases = {
  "g"  => "generate",
  "d"  => "destroy",
  "c"  => "console",
  "s"  => "server",
  "db" => "dbconsole",
  "r"  => "runner",
  "t"  => "test"
}

command = ARGV.shift
command = aliases[command] || command

require 'rails/commands/commands_tasks'

Rails::CommandsTasks.new(ARGV).run_command!(command)
----

TIP: 我们看到，如果 `ARGV` 为空，Rails 就会显示帮助信息。

如果输入的命令使用的是 `s` 而不是 `server`，Rails 就会在上面定义的 `aliases` 散列中查找对应的命令。

[[rails-commands-commands-tasks-rb]]
==== `rails/commands/commands_tasks.rb` 文件

如果输入的是合法的 Rails 命令，Rails 就会通过 `run_command!` 方法调用命令的同名方法。如果 Rails 不能识别该命令，Rails 就会尝试执行同名的 Rake 任务。

[source,ruby]
----
COMMAND_WHITELIST = %w(plugin generate destroy console server dbconsole application runner new version help)

def run_command!(command)
  command = parse_command(command)

  if COMMAND_WHITELIST.include?(command)
    send(command)
  else
    run_rake_task(command)
  end
end
----

本例中输入的是 `server` 命令，因此 Rails 会进一步运行下述代码：

[source,ruby]
----
def set_application_directory!
  Dir.chdir(File.expand_path('../../', APP_PATH)) unless File.exist?(File.expand_path("config.ru"))
end

def server
  set_application_directory!
  require_command!("server")

  Rails::Server.new.tap do |server|
    # 当服务器完成环境设置后，就需要加载应用，
    # 否则传递给服务器的 `--environment` 选项就不会继续传递下去。
    require APP_PATH
    Dir.chdir(Rails.application.root)
    server.start
  end
end

def require_command!(command)
  require "rails/commands/#{command}"
end
----

仅当 `config.ru` 文件无法找到时，才会切换到 Rails 应用根目录（`APP_PATH` 所在文件夹的上一层文件夹，其中 `APP_PATH` 指向 `config/application.rb` 文件）。然后会加载 `rails/commands/server`，其作用是建立 `Rails::Server` 类。

[source,ruby]
----
require 'fileutils'
require 'optparse'
require 'action_dispatch'
require 'rails'

module Rails
  class Server < ::Rack::Server
----

`fileutils` 和 `optparse` 是 Ruby 标准库，分别提供了用于处理文件和解析选项的帮助方法。

[[actionpack-lib-action-dispatch-rb]]
==== `actionpack/lib/action_dispatch.rb` 文件

Action Dispatch 是 Rails 框架的路由组件，提供了路由、会话、常用中间件等功能。

[[rails-commands-server-rb]]
==== `rails/commands/server.rb` 文件

此文件中定义的 `Rails::Server` 类，继承自 `Rack::Server` 类。当调用 `Rails::Server.new` 方法时，会调用此文件中定义的 `initialize` 方法：

[source,ruby]
----
def initialize(*)
  super
  set_environment
end
----

首先调用的 `super` 方法，会调用 `Rack::Server` 类的 `initialize` 方法。

[[rack-lib-rack-server-rb]]
==== `Rack: lib/rack/server.rb` 文件

`Rack::Server` 类负责为所有基于 Rack 的应用（包括 Rails）提供通用服务器接口。

`Rack::Server` 类的 `initialize` 方法的作用是设置几个变量：

[source,ruby]
----
def initialize(options = nil)
  @options = options
  @app = options[:app] if options && options[:app]
end
----

在本例中，`options` 的值是 `nil`，因此这个方法什么也没做。

当 `super` 方法完成 `Rack::Server` 类的 `initialize` 方法的调用后，程序执行流程重新回到 `rails/commands/server.rb` 文件中。此时，会在 `Rails::Server` 对象的上下文中调用 `set_environment` 方法。乍一看这个方法什么也没做：

[source,ruby]
----
def set_environment
  ENV["RAILS_ENV"] ||= options[:environment]
end
----

实际上，其中的 `options` 方法做了很多工作。`options` 方法在 `Rack::Server` 类中定义：

[source,ruby]
----
def options
  @options ||= parse_options(ARGV)
end
----

而 `parse_options` 方法的定义如下：

[source,ruby]
----
def parse_options(args)
  options = default_options

  # 请不要计算 CGI `ISINDEX` 参数的值。
  # http://www.meb.uni-bonn.de/docs/cgi/cl.html
  args.clear if ENV.include?("REQUEST_METHOD")

  options.merge! opt_parser.parse!(args)
  options[:config] = ::File.expand_path(options[:config])
  ENV["RACK_ENV"] = options[:environment]
  options
end
----

其中 `default_options` 方法的定义如下：

[source,ruby]
----

def default_options
  environment  = ENV['RACK_ENV'] || 'development'
  default_host = environment == 'development' ? 'localhost' : '0.0.0.0'

  {
    :environment => environment,
    :pid         => nil,
    :Port        => 9292,
    :Host        => default_host,
    :AccessLog   => [],
    :config      => "config.ru"
  }
end
----

在 `ENV` 散列中不存在 `REQUEST_METHOD` 键，因此可以跳过该行。下一行会合并 `opt_parser` 方法返回的选项，其中 `opt_parser` 方法在 `Rack::Server` 类中定义：

[source,ruby]
----
def opt_parser
  Options.new
end
----

`Options` 类在 `Rack::Server` 类中定义，但在 `Rails::Server` 类中被覆盖了，目的是为了接受不同参数。`Options` 类的 `parse!` 方法的定义，其开头部分如下：

[source,ruby]
----
def parse!(args)
  args, options = args.dup, {}

  opt_parser = OptionParser.new do |opts|
    opts.banner = "Usage: rails server [mongrel, thin, etc] [options]"
    opts.on("-p", "--port=port", Integer,
            "Runs Rails on the specified port.", "Default: 3000") { |v| options[:Port] = v }
  ...
----

此方法为 `options` 散列的键赋值，稍后 Rails 将使用此散列确定服务器的运行方式。`initialize` 方法运行完成后，程序执行流程会跳回 `rails/server`，然后加载之前设置的 `APP_PATH`。

[[config-application]]
==== `config/application.rb` 文件

执行 `require APP_PATH` 时，会加载 `config/application.rb` 文件（前文说过 `APP_PATH` 已经在 `bin/rails` 中定义）。这个文件也是应用的一部分，我们可以根据需要对文件内容进行修改。

[[rails-server-start]]
==== `Rails::Server#start` 方法

`config/application.rb` 文件加载完成后，会调用 `server.start` 方法。这个方法的定义如下：

[source,ruby]
----
def start
  print_boot_information
  trap(:INT) { exit }
  create_tmp_directories
  log_to_stdout if options[:log_stdout]

  super
  ...
end

private

  def print_boot_information
    ...
    puts "=> Run `rails server -h` for more startup options"
  end

  def create_tmp_directories
    %w(cache pids sockets).each do |dir_to_make|
      FileUtils.mkdir_p(File.join(Rails.root, 'tmp', dir_to_make))
    end
  end

  def log_to_stdout
    wrapped_app # 对应用执行 touch 操作，以便设置记录器

    console = ActiveSupport::Logger.new($stdout)
    console.formatter = Rails.logger.formatter
    console.level = Rails.logger.level

    Rails.logger.extend(ActiveSupport::Logger.broadcast(console))
  end
----

这是 Rails 初始化过程中第一次输出信息。`start` 方法为 `INT` 信号创建了一个陷阱，只要在服务器运行时按下 `CTRL-C`，服务器进程就会退出。我们看到，上述代码会创建 `tmp/cache`、`tmp/pids` 和 `tmp/sockets` 文件夹。然后会调用 `wrapped_app` 方法，其作用是先创建 Rack 应用，再创建 `ActiveSupport::Logger` 类的实例。

`super` 方法会调用 `Rack::Server.start` 方法，后者的定义如下：

[source,ruby]
----

def start &blk
  if options[:warn]
    $-w = true
  end

  if includes = options[:include]
    $LOAD_PATH.unshift(*includes)
  end

  if library = options[:require]
    require library
  end

  if options[:debug]
    $DEBUG = true
    require 'pp'
    p options[:server]
    pp wrapped_app
    pp app
  end

  check_pid! if options[:pid]

  # 对包装后的应用执行 touch 操作，以便在创建守护进程之前
  # 加载 `config.ru` 文件（例如在 `chdir` 等操作之前）
  wrapped_app

  daemonize_app if options[:daemonize]

  write_pid if options[:pid]

  trap(:INT) do
    if server.respond_to?(:shutdown)
      server.shutdown
    else
      exit
    end
  end

  server.run wrapped_app, options, &blk
end
----

代码块最后一行中的 `server.run` 非常有意思。这里我们再次遇到了 `wrapped_app` 方法，这次我们要更深入地研究它（前文已经调用过 `wrapped_app` 方法，现在需要回顾一下）。

[source,ruby]
----
@wrapped_app ||= build_app app
----

其中 `app` 方法定义如下：

[source,ruby]
----
def app
  @app ||= options[:builder] ? build_app_from_string : build_app_and_options_from_config
end
...
private
  def build_app_and_options_from_config
    if !::File.exist? options[:config]
      abort "configuration #{options[:config]} not found"
    end

    app, options = Rack::Builder.parse_file(self.options[:config], opt_parser)
    self.options.merge! options
    app
  end

  def build_app_from_string
    Rack::Builder.new_from_string(self.options[:builder])
  end
----

`options[:config]` 的默认值为 `config.ru`，此文件包含如下内容：

----
# 基于 Rack 的服务器使用此文件来启动应用。

require ::File.expand_path('../config/environment', __FILE__)
run <%= app_const %>
----

`Rack::Builder.parse_file` 方法读取 `config.ru` 文件的内容，并使用下述代码解析文件内容：

[source,ruby]
----
app = new_from_string cfgfile, config

...

def self.new_from_string(builder_script, file="(rackup)")
  eval "Rack::Builder.new {\n" + builder_script + "\n}.to_app",
    TOPLEVEL_BINDING, file, 0
end
----

`Rack::Builder` 类的 `initialize` 方法会把接收到的代码块在 `Rack::Builder` 类的实例中执行，Rails 初始化过程中的大部分工作都在这一步完成。在 `config.ru` 文件中，加载 `config/environment.rb` 文件的这一行代码首先被执行：

[source,ruby]
----
require ::File.expand_path('../config/environment', __FILE__)
----

[[config-environment-rb]]
==== `config/environment.rb` 文件

`config.ru` 文件（`rails server`）和 Passenger 都需要加载此文件。这两种运行服务器的方式直到这里才出现了交集，此前的一切工作都只是围绕 Rack 和 Rails 的设置进行的。

此文件的内容以加载 `config/application.rb` 文件开始：

[source,ruby]
----
require File.expand_path('../application', __FILE__)
----

[[config-application-rb]]
==== `config/application.rb` 文件

此文件会加载 `config/boot.rb` 文件：

[source,ruby]
----
require File.expand_path('../boot', __FILE__)
----

对于 `rails server` 这种启动服务器的方式，之前并未加载过 `config/boot.rb` 文件，因此这里会加载该文件；对于 Passenger，之前已经加载过该文件，这里就不会重复加载了。

接下来，有趣的故事就要开始了！

[[loading-rails]]
=== 加载 Rails
