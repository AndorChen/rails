[[active-record-query-interface]]
== Active Record 查询
:imagesdir: ../images
:numbered:

[.chapter-abstract]
--
本文介绍使用 Active Record 从数据库取回数据的不同方法。

读完后，你将学会：

* 如何使用多种方法和条件查找记录。
* 如何指定所查找记录的排序方式、想要取回的属性、分组方式和其他特性。
* 如何使用预先加载以减少数据检索所需的数据库查询的数量。
* 如何使用动态查找器方法。
* 如何通过方法链来连续使用多个 Active Record 方法。
* 如何检查某个记录是否存在。
* 如何在 Active Record 模型上做各种计算。
* 如何在关联上执行 `EXPLAIN` 命令。
--

如果你习惯直接使用 SQL 来查找数据库记录，那么你通常会发现 Rails 为执行相同操作提供了更好的方式。在大多数情况下，Active Record 使你无需使用 SQL。

本文中的示例代码会用到下面的一个或多个模型：

NOTE: 除非另有说明，下面所有模型都使用 `id` 作为主键。

[source,ruby]
----
class Client < ApplicationRecord
  has_one :address
  has_many :orders
  has_and_belongs_to_many :roles
end
----

[source,ruby]
----
class Address < ApplicationRecord
  belongs_to :client
end
----

[source,ruby]
----
class Order < ApplicationRecord
  belongs_to :client, counter_cache: true
end
----

[source,ruby]
----
class Role < ApplicationRecord
  has_and_belongs_to_many :clients
end
----

Active Record 会为你执行数据库查询，它和大多数数据库系统兼容，包括 MySQL、MariaDB、PostgreSQL 和 SQLite。不管使用哪个数据库系统，Active Record 方法的用法总是相同。

[[retrieving-objects-from-the-database]]
=== 从数据库取回对象

Active Record 提供了几个用于从数据库取回对象的查找器方法。查找器方法接受参数并执行指定的数据库查询，使我们无需直接使用 SQL。

下面列出了这些查找器方法：

* `find`
* `create_with`
* `distinct`
* `eager_load`
* `extending`
* `from`
* `group`
* `having`
* `includes`
* `joins`
* `left_outer_joins`
* `limit`
* `lock`
* `none`
* `offset`
* `order`
* `preload`
* `readonly`
* `references`
* `reorder`
* `reverse_order`
* `select`
* `distinct`
* `where`

上面的所有方法都会返回 `ActiveRecord::Relation` 的实例。

`Model.find(options)` 执行的主要操作可以概括为：

* 把提供的选项转换为等价的 SQL 查询。
* 触发 SQL 查询并从数据库取回对应结果。
* 为每个查询结果实例化对应的模型对象。
* 当存在回调时，先调用 `after_find` 回调再调用 `after_initialize` 回调。

[[retrieving-a-single-object]]
==== 取回单个对象

Active Record 为取回单个对象提供了几个不同的方法。

[[find]]
===== `find` 方法

可以使用 `find` 方法取回指定主键对应的对象，指定主键时可以使用多个选项。例如：

[source,ruby]
----
# Find the client with primary key (id) 10.
client = Client.find(10)
# => #<Client id: 10, first_name: "Ryan">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients WHERE (clients.id = 10) LIMIT 1
----

如果没有找到匹配的记录，`find` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

还可以使用 `find` 方法查询多个对象，方法是调用 `find` 方法并传入主键的数组。返回值是包含所提供的主键的所有匹配记录的数组。例如：

[source,ruby]
----
# Find the clients with primary keys 1 and 10.
client = Client.find([1, 10]) # Or even Client.find(1, 10)
# => [#<Client id: 1, first_name: "Lifo">, #<Client id: 10, first_name: "Ryan">]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients WHERE (clients.id IN (1,10))
----

WARNING: 如果所提供的主键都没有匹配记录，那么 `find` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

[[take]]
===== `take` 方法

`take` 方法会取回一条记录而不考虑排序问题。例如：

[source,ruby]
----
client = Client.take
# => #<Client id: 1, first_name: "Lifo">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients LIMIT 1
----

如果没有找到记录，`take` 方法会返回 `nil`，而不会引发异常。

`take` 方法接受数字作为参数，并返回不超过指定数量的查询结果。例如：

[source,ruby]
----
client = Client.take(2)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 220, first_name: "Sara">
# ]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients LIMIT 2
----

`take!` 方法的行为和 `take` 方法类似，区别在于如果没有找到匹配的记录，`take!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

NOTE: 对于不同的数据库引擎，`take` 方法取回的记录可能不一样。

[[first]]
===== `first` 方法

`first` 方法默认会查找按主键排序的第一条记录。例如：

[source,ruby]
----
client = Client.first
# => #<Client id: 1, first_name: "Lifo">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 1
----

如果没有找到匹配的记录，`first` 方法会返回 `nil`，而不会引发异常。

如果默认作用域 （请参阅 <<hactive_record_querying#applying-a-default-scope>> 一节）包含排序方法，`first` 方法会返回按照这个顺序排序的第一条记录。

`first` 方法接受数字作为参数，并返回不超过指定数量的查询结果。例如：

[source,ruby]
----
client = Client.first(3)
# => [
#   #<Client id: 1, first_name: "Lifo">,
#   #<Client id: 2, first_name: "Fifo">,
#   #<Client id: 3, first_name: "Filo">
# ]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id ASC LIMIT 3
----

对于使用 `order` 排序的集合，`first` 方法返回按照指定属性排序的第一条记录。例如：

[source,ruby]
----
client = Client.order(:first_name).first
# => #<Client id: 2, first_name: "Fifo">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.first_name ASC LIMIT 1
----

`first!` 方法的行为和 `first` 方法类似，区别在于如果没有找到匹配的记录，`first!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

[[last]]
===== `last` 方法

`last` 方法默认会查找按主键排序的最后一条记录。例如：

[source,ruby]
----
client = Client.last
# => #<Client id: 221, first_name: "Russel">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 1
----

如果没有找到匹配的记录，`last` 方法会返回 `nil`，而不会引发异常。

如果默认作用域 （请参阅 <<hactive_record_querying#applying-a-default-scope>> 一节）包含排序方法，`last` 方法会返回按照这个顺序排序的最后一条记录。

`last` 方法接受数字作为参数，并返回不超过指定数量的查询结果。例如：

[source,ruby]
----
client = Client.last(3)
# => [
#   #<Client id: 219, first_name: "James">,
#   #<Client id: 220, first_name: "Sara">,
#   #<Client id: 221, first_name: "Russel">
# ]
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.id DESC LIMIT 3
----

对于使用 `order` 排序的集合，`last` 方法返回按照指定属性排序的最后一条记录。例如：

[source,ruby]
----
client = Client.order(:first_name).last
# => #<Client id: 220, first_name: "Sara">
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients ORDER BY clients.first_name DESC LIMIT 1
----

`last!` 方法的行为和 `last` 方法类似，区别在于如果没有找到匹配的记录，`last!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。

[[find-by]]
===== `find_by` 方法

`find_by` 方法查找匹配指定条件的第一条记录。 例如：

[source,ruby]
----
Client.find_by first_name: 'Lifo'
# => #<Client id: 1, first_name: "Lifo">

Client.find_by first_name: 'Jon'
# => nil
----

上面的代码等价于：

[source,ruby]
----
Client.where(first_name: 'Lifo').take
----

和上面的代码等价的 SQL 是：

[source,sql]
----
SELECT * FROM clients WHERE (clients.first_name = 'Lifo') LIMIT 1
----

`find_by!` 方法的行为和 `find_by` 方法类似，区别在于如果没有找到匹配的记录，`find_by!` 方法会引发 `ActiveRecord::RecordNotFound` 异常。例如：

[source,ruby]
----
Client.find_by! first_name: 'does not exist'
# => ActiveRecord::RecordNotFound
----

上面的代码等价于：

[source,ruby]
----
Client.where(first_name: 'does not exist').take!
----

[[retrieving-multiple-objects-in-batches]]
=== 批量取回多个对象
